<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>To be or not to be?</title>
  
  <subtitle>刷题学习笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-28T14:18:26.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Gh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetCode-209-长度最小的子数组</title>
    <link href="http://yoursite.com/2020/06/28/leetCode-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/06/28/leetCode-209-长度最小的子数组/</id>
    <published>2020-06-28T14:18:26.000Z</published>
    <updated>2020-06-28T14:18:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。</p><a id="more"></a><blockquote><p>示例:</p><p>输入: s = 7, nums = [2,3,1,2,4,3]</p><p>输出: 2</p><p>解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</p></blockquote><p><strong>进阶：</strong></p><p>如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>最简单的想法就是暴力解法，枚举数组nums中的每个下标作为子数组的开始下标，依次向后面加，找到满足条件的最小的连续子数组。</p><p>第二种想法是双指针，暴力解法中存在大量的重复计算，我们可以用双指针的方法来维护一个区间，当区间值的和大于等于s的时候，我们就用区间的小标更新下最小长度。然后把这个区间的左边界给+1，然后再次循环判断。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.length; j++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= s)&#123;</span><br><span class="line">                    min = Math.min(min,j - i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="number">0</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= s)&#123;</span><br><span class="line">                min = Math.min(right - left, min);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += nums[right++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理剩下左边界可能小于边界的范围</span></span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= s)&#123;</span><br><span class="line">            min = Math.min(right - left, min);</span><br><span class="line">            sum -= nums[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="number">0</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-718-最长重复子数组</title>
    <link href="http://yoursite.com/2020/06/28/leetCode-718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/06/28/leetCode-718-最长重复子数组/</id>
    <published>2020-06-28T05:15:26.000Z</published>
    <updated>2020-06-28T05:15:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p><a id="more"></a><blockquote><p>示例：</p><p>输入：</p><p>A: [1,2,3,2,1]</p><p>B: [3,2,1,4,7]</p><p>输出：3</p><p>解释：</p><p>长度最长的公共子数组是 [3, 2, 1] 。</p></blockquote><p>提示：</p><ul><li>1 &lt;= len(A), len(B) &lt;= 1000</li><li>0 &lt;= A[i], B[i] &lt; 100</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>第一种思路就是暴力求解，依次比较数组 A 中的起始位置 i 与数组 B 中的起始位置 j,找到公共相等的部分。这样做时间复杂度为 <code>$O(n^3)$</code>，会超时。</p><p>暴力求解的过程中有大量的重复计算，既然公共子串的关系是连续的说明如果想要当前公共子串的长度增加除了当前数字相等的情况下，还需要前面数字相等。所以定义dp[i][j]的状态为以A数组中第i个数字和B数组第j个数字结束时公共字串的个数。所以动态转移方程是当<code>A[i] == B[j]</code>(当前两个数组数字相等)<code>dp[i][j] = dp[i - 1][j - 1] + 1</code>,这样需要<code>$O(n^2)$</code>的时间复杂度和<code>$O(n^2)$</code>的空间相当于拿空间换时间，数据范围是1000，所以可以通过。</p><p>第三种思路就是滑动窗口,可以用把A数组当作一个窗口相当于数组B向后移动，每向后移动一位都比较一下两个数组中在同一窗口的值是否相等。只把A数组当作窗口移动和B数组比较的话，是不能枚举出所有情况，例如给定的<code>A = {1,2,3,4,5}</code>,<code>B={8,2,3,4,6}</code>，A走完以后，A中第一个元素和全部B元素比较了一遍，但是A里第二个元素并没有和B里第一个元素比较。所以应该再把B做为相对于A的窗口再走一遍。</p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a><font color="#8B475D">我的代码</font></h2><p>暴力：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.length; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(A[i] == B[j])&#123;</span><br><span class="line">                    <span class="keyword">int</span> m = i;</span><br><span class="line">                    <span class="keyword">int</span> n = j;</span><br><span class="line">                    <span class="keyword">while</span>(m &lt; A.length &amp;&amp; n &lt; B.length &amp;&amp; A[m++] == B[n++])&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max,count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dp:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length + <span class="number">1</span>][B.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; B.length + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滑动窗口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length, m = B.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = Math.min(m, n - i);</span><br><span class="line">            <span class="keyword">int</span> max = maxLength(A, B, i, <span class="number">0</span>, len);</span><br><span class="line">            res = Math.max(res, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = Math.min(n, m - i);</span><br><span class="line">            <span class="keyword">int</span> max = maxLength(A, B, <span class="number">0</span>, i, len);</span><br><span class="line">            res = Math.max(res, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; len; l++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i + l] == B[j + l]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-67-二进制求和</title>
    <link href="http://yoursite.com/2020/06/23/leetCode-67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/"/>
    <id>http://yoursite.com/2020/06/23/leetCode-67-二进制求和/</id>
    <published>2020-06-23T01:30:26.000Z</published>
    <updated>2020-06-23T01:30:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p><p>输入为 非空 字符串且只包含数字 1 和 0。</p><a id="more"></a><blockquote><p>示例1:</p><p>输入: a = “11”, b = “1”</p><p>输出: “100”</p><p>示例2:</p><p>输入: a = “1010”, b = “1011”</p><p>输出: “1010”</p></blockquote><p><strong>提示：</strong></p><ul><li>每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。</li><li>1 &lt;= a.length, b.length &lt;= 10^4</li><li>字符串如果不是 “0” ，就都不含前导零。</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>思路就是把字符串ab每位相加，控制好进位就可以了。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = a.length() &gt; b.length() ? a.length() : b.length();</span><br><span class="line">        <span class="comment">//控制进位</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            carry += i &lt; a.length() ? (a.charAt(a.length() - <span class="number">1</span> - i) - <span class="string">'0'</span>) : <span class="number">0</span>;</span><br><span class="line">            carry += i &lt; b.length() ? (b.charAt(b.length() - <span class="number">1</span> - i) - <span class="string">'0'</span>) : <span class="number">0</span>;</span><br><span class="line">            res.append(carry % <span class="number">2</span>);</span><br><span class="line">            carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">            res.append(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;给你两个二进制字符串，返回它们的和（用二进制表示）。&lt;/p&gt;
&lt;p&gt;输入为 非空 字符串且只包含数字 1 和 0。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-494-目标和</title>
    <link href="http://yoursite.com/2020/06/23/leetCode-494-%E7%9B%AE%E6%A0%87%E5%92%8C/"/>
    <id>http://yoursite.com/2020/06/23/leetCode-494-目标和/</id>
    <published>2020-06-23T00:31:26.000Z</published>
    <updated>2020-06-23T00:31:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。</p><p>如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。</p><p>一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</p><a id="more"></a><blockquote><p>示例1：</p><p>输入：head = [4,2,8]</p><p>root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]</p><p>输出：true</p><p>解释：树中蓝色的节点构成了与链表对应的子路径。</p><p>示例2：</p><p>输入：head = [1,4,2,6]</p><p>root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]</p><p>输出：true</p></blockquote><p><strong>提示：</strong></p><ul><li>二叉树和链表中的每个节点的值都满足 1 &lt;= node.val &lt;= 100 。</li><li>链表包含的节点数目在 1 到 100 之间。</li><li>二叉树包含的节点数目在 1 到 2500 之间。</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>最一开始的思路就是直接做dfs，大概思路就是如果head的值和root的值不同，递归的把head和root的左右节点比较。如果相等，在把head指向下一个节点。但是这样做是行不通的，如果在某个时刻，遍历到链表和树结点的值不同，那么从当前树节点继续往下找，但是是从链表的头结点开始。问题是，之前遍历过的树节点可能是正确路径的一部分，这里从链表头结点开始就跳过了这部分。比如链表是 1 2 1 2 4，树节点遍历是 1 2 1 2 1 2 4。</p><p>为了解决回溯问题，可以双重递归，辅助递归函数主要判断当head节点值和root节点值相等时，继续遍历可能相等的节点。主递归函数来控制回溯。当root节点和head节点前面若干节点相等，但是后面节点不行等的时候，不能否定这一段存在正确路径的一部分。所以主递归函数记录开始的起点，当辅助函数返回false，这时候继续遍历传进去root的左右节点。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubPath</span><span class="params">(ListNode head, TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(head,root) || isSubPath(head,root.left) || isSubPath(head,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(ListNode head,TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//链表走完 返回真</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根节点走完 链表没走完返回false</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点值相同，继续递归</span></span><br><span class="line">        <span class="keyword">if</span>(head.val == root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(head.next,root.left) || dfs(head.next,root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点值不同返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。&lt;/p&gt;
&lt;p&gt;如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。&lt;/p&gt;
&lt;p&gt;一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-62-不同路径</title>
    <link href="http://yoursite.com/2020/06/22/leetCode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/06/22/leetCode-62-不同路径/</id>
    <published>2020-06-22T15:31:26.000Z</published>
    <updated>2020-06-22T15:31:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><a id="more"></a><blockquote><p>示例1:</p><p>输入: m = 3, n = 2</p><p>输出: 3</p><p>解释:</p><p>从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li><p>向右 -&gt; 向右 -&gt; 向下</p></li><li><p>向右 -&gt; 向下 -&gt; 向右</p></li><li><p>向下 -&gt; 向右 -&gt; 向右</p></li></ol><p>示例 2:</p><p>输入: m = 7, n = 3</p><p>输出: 28</p></blockquote><p><strong>提示：</strong></p><ul><li>1 &lt;= m, n &lt;= 100</li><li>题目数据保证答案小于等于 2 * 10 ^ 9</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>第一种思路是递归，但是会有大量子问题重叠。</p><p>定义dp状态为使用一个mn的矩阵存储矩阵中每个元素为左上角到当前位置的路径数，机器人每次只能向下或者向右移动一步，所以下一个状态是由左一个状态和上一个状态转移而来，即<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><p>超时DFS:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,m,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= m - <span class="number">1</span> &amp;&amp; y &gt;= n - <span class="number">1</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; m - <span class="number">1</span> &amp;&amp; y &lt; n - <span class="number">1</span>)&#123;</span><br><span class="line">            dfs(x + <span class="number">1</span>,y,m,n);</span><br><span class="line">            dfs(x,y + <span class="number">1</span>,m,n);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &gt;= m - <span class="number">1</span>)&#123;</span><br><span class="line">            dfs(x,y + <span class="number">1</span>,m,n);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(x + <span class="number">1</span>,y,m,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-124-二叉树中的最大路径和</title>
    <link href="http://yoursite.com/2020/06/22/leetCode-124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://yoursite.com/2020/06/22/leetCode-124-二叉树中的最大路径和/</id>
    <published>2020-06-22T13:31:26.000Z</published>
    <updated>2020-06-22T13:31:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>给定一个非空二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p><a id="more"></a><blockquote><p>示例 1:</p><p>输入: [1,2,3]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br></pre></td></tr></table></figure><blockquote><p>输出: 6</p><p>示例2:</p><p>输入: [-10,9,20,null,null,15,7]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> -10</span><br><span class="line"> /  \</span><br><span class="line">9   20</span><br><span class="line">   /  \</span><br><span class="line">  15   7</span><br></pre></td></tr></table></figure><blockquote><p>输出: 42</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>一开始没看懂题目意思，以为要计算任意节点到任意节点的不同路径数目总和，后来才发现是计算该路径上所有节点(包括这两个节点)的val值的最大和。</p><p>用dfs的思路，对于整个树，每个节点都可以抽象为根节点，左子树，右子树三部分，同时递归的时候同时可以求出左子树、右子树两者路径最大的一方就可以了。因为节点的val可能为负数所以最大路径可能存在六种情况：</p><ul><li>左子树值最大</li><li>右子树值最大</li><li>根节点值最大</li><li>左子树 + 根节点 值最大</li><li>右子树 + 根节点 值最大</li><li>根节点 + 左子树 + 右子树 值最大</li></ul><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存最大路径和</span></span><br><span class="line">    <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = Math.max(dfs(root.left),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> r = Math.max(dfs(root.right),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//如果前面l和r和root.val的值如果都是负数，返回了当前值，不可能是返回递归出口的0</span></span><br><span class="line">        res = Math.max(res, root.val + l + r);</span><br><span class="line">        <span class="comment">//返回的路径中必须要有根节点</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(l + root.val,r + root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;给定一个非空二叉树，返回其最大路径和。&lt;/p&gt;
&lt;p&gt;本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-101-对称二叉树</title>
    <link href="http://yoursite.com/2020/06/21/leetCode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/06/21/leetCode-101-对称二叉树/</id>
    <published>2020-06-21T13:11:26.000Z</published>
    <updated>2020-06-21T13:11:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong></p><p>你可以运用递归和迭代两种方法解决这个问题吗？</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>主要思路就是根据对称的特点，就是在树的每一层中的节点中要最左节点和最右节点相等，从左向右第二个节点要和从右向左第二个节点相等，一直到判断完这一层。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><p>递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="keyword">true</span> : check(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode left,TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先去判断如果两个子节点都是空返回真</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一个节点为空返回false</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右节点值相等，并且子节点对称相等</span></span><br><span class="line">        <span class="keyword">return</span> (left.val == right.val) &amp;&amp; check(left.left,right.right) &amp;&amp; check(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root.left);</span><br><span class="line">        queue.offer(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node1 = queue.poll();</span><br><span class="line">            TreeNode node2 = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span> || node1.val != node2.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断node1的左节点和node2的右节点</span></span><br><span class="line">            queue.offer(node1.left);</span><br><span class="line">            queue.offer(node2.right);</span><br><span class="line">            <span class="comment">//判断node2的左节点和node1的右节点</span></span><br><span class="line">            queue.offer(node1.right);</span><br><span class="line">            queue.offer(node2.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;给定一个二叉树，检查它是否是镜像对称的。&lt;/p&gt;
&lt;p&gt;例如，二叉树 [1,2,2,3,4,4,3] 是对称的。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-869-重新排序得到2的幂</title>
    <link href="http://yoursite.com/2020/06/20/leetCode-869-%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B02%E7%9A%84%E5%B9%82/"/>
    <id>http://yoursite.com/2020/06/20/leetCode-869-重新排序得到2的幂/</id>
    <published>2020-06-20T15:31:26.000Z</published>
    <updated>2020-06-20T15:31:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>给定正整数 N，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。</p><p>如果我们可以通过上述方式得到2 的幂，返回 true；否则，返回 false。</p><a id="more"></a><blockquote><p>示例 1：</p><p>输入：1</p><p>输出：true</p><p>示例 2：</p><p>输入：10</p><p>输出：false</p><p>示例 3：</p><p>输入：16</p><p>输出：true</p><p>示例 4：</p><p>输入：24</p><p>输出：false</p><p>示例 5：</p><p>输入：46</p><p>输出：true</p></blockquote><p><strong>提示：</strong></p><p>1 &lt;= N &lt;= 10^9</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>第一种思路就是将N转化成字符然后全排列，因为在int范围内2的幂只有31个，所以直接存到map中，然后判断全排列的数字中有一个符合条件就可以了。时间复杂度上面，因为在递归过程中每位数字都占用一层空间，而且是逐级递减的所以是O(n!)。假如<code>Integer.MAX_VALUE</code>十进制最多10位数字，所以是10的阶乘大概是三百多万，这个时间是可以接受的，空间上需要map储存一个int范围内2的幂是31可以忽略不记，递归产生栈的空间最大深度是<code>Integer.MAX_VALUE</code>也是10，所以可以认为是O(1)的空间。</p><p>第二种思路比较巧妙就是先把int范围内2的幂的31数字中的的每一个数字排序(数字每位按照大小排序)然后转化字符串，再把给定的数字N排序，直接用equals比较。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reorderedPowerOf2</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//Integer范围内所有2的幂次方数字存到map中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)&#123;</span><br><span class="line">            map.put(<span class="number">2</span> &lt;&lt; i,<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chs = String.valueOf(N).toCharArray();</span><br><span class="line">        <span class="keyword">return</span> permute(chs,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//全排列数字</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">permute</span><span class="params">(<span class="keyword">char</span>[] chs,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= chs.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chs[<span class="number">0</span>] != <span class="string">'0'</span> &amp;&amp; map.containsKey(Integer.valueOf(String.valueOf(chs))))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; chs.length; i++)&#123;</span><br><span class="line">                swap(chs,index,i);</span><br><span class="line">                <span class="comment">//map中存在当前排列的数字直接返回</span></span><br><span class="line">                <span class="keyword">if</span>(permute(chs,index + <span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(chs,index,i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chs,<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = chs[l];</span><br><span class="line">        chs[l] = chs[r];</span><br><span class="line">        chs[r] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reorderedPowerOf2</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将数字N每位排序转化位字符串</span></span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chs = String.valueOf(N).toCharArray();</span><br><span class="line">        Arrays.sort(chs);</span><br><span class="line">        String num = String.valueOf(chs);</span><br><span class="line">        <span class="comment">//判断int范围内2的幂的31数字中转化为字符串后是否N相等</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] temp = String.valueOf(Integer.valueOf((<span class="number">2</span> &lt;&lt; i))).toCharArray();</span><br><span class="line">            Arrays.sort(temp);</span><br><span class="line">            <span class="keyword">if</span>(num.equals(String.valueOf(temp)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;给定正整数 N，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。&lt;/p&gt;
&lt;p&gt;如果我们可以通过上述方式得到2 的幂，返回 true；否则，返回 false。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-125-验证回文串</title>
    <link href="http://yoursite.com/2020/06/19/leetCode-125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/06/19/leetCode-125-验证回文串/</id>
    <published>2020-06-19T15:31:26.000Z</published>
    <updated>2020-06-19T15:31:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><a id="more"></a><p><strong>说明：</strong> 本题中，我们将空字符串定义为有效的回文串。</p><blockquote><p>示例 1:</p><p>输入: “A man, a plan, a canal: Panama”</p><p>输出: true</p><p>示例 2:</p><p>输入: “race a car”</p><p>输出: false</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>给定的字符串中忽略大写和小写，所以需要先把转成统一大写或小写。只考虑字母和数字字符，在用双指针验证时候需要排除其他字符。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chs = s.toLowerCase().toCharArray();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = chs.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//双指针判断字符数组是否是回文串</span></span><br><span class="line">        <span class="comment">//排除'0~9'和'a~z'之外的所有字符</span></span><br><span class="line">        <span class="keyword">while</span>(right &gt; left)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(chs[left] &gt;= <span class="string">'0'</span> &amp;&amp; chs[left] &lt;= <span class="string">'9'</span>) &amp;&amp; !(chs[left] &gt;= <span class="string">'a'</span> &amp;&amp; chs[left] &lt;= <span class="string">'z'</span>))&#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!(chs[right] &gt;= <span class="string">'0'</span> &amp;&amp; chs[right] &lt;= <span class="string">'9'</span>) &amp;&amp; !(chs[right] &gt;= <span class="string">'a'</span> &amp;&amp; chs[right] &lt;= <span class="string">'z'</span>))&#123;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(chs[left] != chs[right])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-1028-从先序遍历还原二叉树</title>
    <link href="http://yoursite.com/2020/06/18/leetCode-1028-%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/06/18/leetCode-1028-从先序遍历还原二叉树/</id>
    <published>2020-06-18T14:31:26.000Z</published>
    <updated>2020-06-18T14:31:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>我们从二叉树的根节点 <code>root</code>开始进行深度优先搜索。</p><p>在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。</p><p>如果节点只有一个子节点，那么保证该子节点为左子节点。</p><p>给出遍历输出S，还原树并返回其根节点<code>root</code>。</p><a id="more"></a><blockquote><p>示例1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;       1</span><br><span class="line">&gt;      / \    </span><br><span class="line">&gt;     2   5</span><br><span class="line">&gt;    / \ / \</span><br><span class="line">&gt;   3  4 6  7</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>输入：”1-2–3–4-5–6–7”</p><p>输出：[1,2,5,3,4,6,7]</p><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;       1</span><br><span class="line">&gt;      / \</span><br><span class="line">&gt;     2   5</span><br><span class="line">&gt;    /   /</span><br><span class="line">&gt;   3   6</span><br><span class="line">&gt;  /   /</span><br><span class="line">&gt; 4   7</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>输入：”1-2–3—4-5–6—7”</p><p>输出：[1,2,5,3,null,6,null,4,null,7]</p></blockquote><p><strong>提示：</strong></p><ul><li>2 &lt;= A.length &lt;= 50000</li><li>1 &lt;= A[i] &lt;= 1000</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>根据先序遍历的特点和给定的字符串判断，例如<code>&quot;1-2--3--4-5--6--7&quot;</code></p><ul><li>首先确定根节点是1。</li><li>先序遍历的下一个节点是根节点的左节点，如果是一个<code>-</code>的话，说明是左子树（也有可能是右子树，但是题目说明了如果节点只有一个子节点，那么保证该子节点为左子节点。）</li><li>下一个节点是3，和前一个节点相差一个深度，所以必定是上个节点的左节点</li><li>下一个节点是4，和上个节点深度相同，则说明上个节点是叶子节点，这个节点是上个节点的兄弟节点。</li><li>继续遍历节点是5，深度小于上一个节点，找到深度等于当前深度的节点2，2是根节点的左节点，这个就是2的兄弟节点即根节点的右节点。下面同样判断。</li></ul><p>在递归构建树的过程中先递归的构建左子树，但前提条件是序列的下一个数值字符之前对应的<code>-</code>字符的数量应该与其深度匹配,不匹配说明当前节点是叶子节点，开始递归的构建右子树。右子树构建的前提同样是下一个数值字符之前对应的<code>-</code>字符的数量应该与其深度匹配。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">recoverFromPreorder</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(S,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">dfs</span><span class="params">(String s,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="comment">//记录当前层中有多少个-</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到数字再第几层</span></span><br><span class="line">        <span class="keyword">while</span>(index + level &lt; s.length() &amp;&amp; s.charAt(index + level) == <span class="string">'-'</span>)&#123;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果遍历的深度和获取到的深度不一致,说明上个节点就是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(depth != level)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> next = index + level;</span><br><span class="line">        <span class="comment">//数字长度可能大于一位</span></span><br><span class="line">        <span class="keyword">while</span>(next &lt; s.length() &amp;&amp; s.charAt(next) != <span class="string">'-'</span>)&#123;</span><br><span class="line">            next++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = Integer.parseInt(s.substring(level + index,next));</span><br><span class="line">        index = next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造节点</span></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        node.left = dfs(s,depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果左子树为空，那么右子树也为空</span></span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//左子树不为空</span></span><br><span class="line">            node.right = dfs(s,depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;我们从二叉树的根节点 &lt;code&gt;root&lt;/code&gt;开始进行深度优先搜索。&lt;/p&gt;
&lt;p&gt;在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。&lt;/p&gt;
&lt;p&gt;如果节点只有一个子节点，那么保证该子节点为左子节点。&lt;/p&gt;
&lt;p&gt;给出遍历输出S，还原树并返回其根节点&lt;code&gt;root&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-1014-最佳观光组合</title>
    <link href="http://yoursite.com/2020/06/17/leetCode-1014-%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2020/06/17/leetCode-1014-最佳观光组合/</id>
    <published>2020-06-17T03:39:26.000Z</published>
    <updated>2020-06-17T03:39:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>给定正整数数组A，A[i]表示第 i 个观光景点的评分，并且两个景点i 和j之间的距离为j - i。</p><p>一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。</p><p>返回一对观光景点能取得的最高分。</p><a id="more"></a><blockquote><p>示例：</p><p>输入：[8,1,5,2,6]</p><p>输出：11</p><p>解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11</p></blockquote><p><strong>提示：</strong></p><ul><li>2 &lt;= A.length &lt;= 50000</li><li>1 &lt;= A[i] &lt;= 1000</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>最直接的暴力解法就是根据题目的公式，做两层遍历，第一层是i，第二层是j，然后直接套用公式，但是这样做时间复杂度是<code>O(n^2)</code>的,数据给定的范围是50000会超时。</p><p>题目给定的公式是<code>A[i] + A[j] + i - j</code>,可以将公式拆分来看，<code>A[i] + i</code>和 <code>A[j] - j</code>两部分，并且要求i在j前面，所以可以使用一个变量pre记录数组中前一个元素的下标和数组下标对应值的和(相当于<code>A[i] + i</code>)，当前遍历到的元素，先计算<code>A[j] - j</code>与pre的和是否为最大，计算完以后在看当前元素的下标对应值是否需要更新，如果大于前一个元素则更新。这样就可以通过一次遍历来计算出给定公式的最大值。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> pre = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; A.length;j++)&#123;</span><br><span class="line">            res = Math.max(res,pre + A[j] - j);</span><br><span class="line">            pre = Math.max(pre,A[j] + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;给定正整数数组A，A[i]表示第 i 个观光景点的评分，并且两个景点i 和j之间的距离为j - i。&lt;/p&gt;
&lt;p&gt;一对景点（i &amp;lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。&lt;/p&gt;
&lt;p&gt;返回一对观光景点能取得的最高分。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-297-二叉树的序列化与反序列化</title>
    <link href="http://yoursite.com/2020/06/16/leetCode-297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://yoursite.com/2020/06/16/leetCode-297-二叉树的序列化与反序列化/</id>
    <published>2020-06-16T02:39:26.000Z</published>
    <updated>2020-06-16T02:39:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><blockquote><p>示例:</p><p>你可以将以下二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;    1</span><br><span class="line">&gt;   / \</span><br><span class="line">&gt;  2   3</span><br><span class="line">&gt;     / \</span><br><span class="line">&gt;    4   5</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>序列化为 “[1,2,3,null,null,4,5]”</p></blockquote><p><strong>提示:</strong>这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其&gt;他的方法解决这个问题。</p><p><strong>说明:</strong> 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>将树序列化为字符串，说白了就是树的遍历，不同的遍历方式记录的方式也不同，所以再反序列化的时候也需要前面遍历树的特点来根据字符串中记录节点的关系重新构造二叉树。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serializeDfs(root,<span class="keyword">new</span> StringBuilder()).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据树的前序遍历，将遍历到的节点构造成字符串</span></span><br><span class="line">    <span class="function">StringBuilder <span class="title">serializeDfs</span><span class="params">(TreeNode root,StringBuilder str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            str.append(<span class="string">"null"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            str.append(<span class="string">","</span>);</span><br><span class="line">            str = serializeDfs(root.left,str);</span><br><span class="line">            str = serializeDfs(root.right,str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        String[] split = data.split(<span class="string">","</span>);</span><br><span class="line">        List&lt;String&gt; strs = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(split));</span><br><span class="line">        <span class="keyword">return</span> deserializeDfs(strs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前面序列化使用的前序遍历，反序列化需要根据前序遍历构造出字符串中的特点(根-&gt;左-&gt;右)的重新构造二叉树</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">deserializeDfs</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.get(<span class="number">0</span>).equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构造新节点</span></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(Integer.valueOf(list.get(<span class="number">0</span>)));</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">        node.left = deserializeDfs(list);</span><br><span class="line">        node.right = deserializeDfs(list);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-14-最长公共前缀</title>
    <link href="http://yoursite.com/2020/06/15/leetCode-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>http://yoursite.com/2020/06/15/leetCode-14-最长公共前缀/</id>
    <published>2020-06-15T01:39:26.000Z</published>
    <updated>2020-06-15T01:39:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><blockquote><p>示例1:</p><p>输入: [“flower”,”flow”,”flight”]</p><p>输出: “fl”</p><p>示例 2:</p><p>输入: [“dog”,”racecar”,”car”]</p><p>输出: “”</p><p>解释: 输入不存在公共前缀。</p></blockquote><p><strong>说明:</strong></p><p>所有输入只包含小写字母<code>a-z</code>。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>第一种思路就是暴力解法，从头到尾依次两两求出公共前缀。因为每次都需要把当前字符串和前缀字符串比较，所以时间复杂度是O(n * m),m是字符数组中所有字符串的平均长度。</p><p>既然可以依次比较字符串找公共前缀，那么也可以两两比较，找到两两的公共前缀，再将公共前缀合并，就是分治的思路。但是分治的思路对于这道题相对于直接遍历仅仅减少总体的比较单词间的前缀次数。由于递归产生栈的深度，增添了额外的空间的复杂度，其中栈的深度是<code>log(n)</code>n是字符数组中字符串的个数，加上每层栈都需要保留前缀，所以总体空间复杂度是<code>O(m*log n)</code>。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><p>暴力：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length &lt;= <span class="number">0</span> || strs[<span class="number">0</span>].equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//从头到尾遍历strs数组找公共前缀</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(strs[i].equals(<span class="string">""</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到已知前缀和当前字符串的公共前缀</span></span><br><span class="line">            <span class="keyword">int</span> len = prefix.length() &lt; strs[i].length() ? prefix.length() : strs[i].length();</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; len)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prefix.charAt(i) != strs[i].charAt(i))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            prefix = strs[i].substring(<span class="number">0</span>,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分治：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merge(<span class="number">0</span>,strs.length - <span class="number">1</span>,strs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">merge</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right,String[] strs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">return</span> strs[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        String pre = merge(left,mid,strs);</span><br><span class="line">        String post = merge(mid + <span class="number">1</span>,right,strs);</span><br><span class="line">        <span class="keyword">return</span> findPrefix(pre,post);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并公共前缀</span></span><br><span class="line">    <span class="function">String <span class="title">findPrefix</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s1.length() &lt; s2.length() ? s1.length() : s2.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i) != s2.charAt(i))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1.substring(<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;/p&gt;
&lt;p&gt;如果
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-1300-转变数组后最接近目标值的数组和</title>
    <link href="http://yoursite.com/2020/06/14/leetCode-1300-%E8%BD%AC%E5%8F%98%E6%95%B0%E7%BB%84%E5%90%8E%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <id>http://yoursite.com/2020/06/14/leetCode-1300-转变数组后最接近目标值的数组和/</id>
    <published>2020-06-14T01:39:26.000Z</published>
    <updated>2020-06-14T01:39:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>给你一个整数数组<code>arr</code> 和一个目标值<code>target</code> ，请你返回一个整数<code>value</code>，使得将数组中所有大于<code>value</code> 的值变成<code>value</code> 后，数组的和最接近<code>target</code>（最接近表示两者之差的绝对值最小）。</p><p>如果有多种使得和最接近<code>target</code>的方案，请你返回这些整数中的最小值。</p><p>请注意，答案不一定是<code>arr</code> 中的数字。</p><blockquote><p>示例 1：</p><p>输入：arr = [4,9,3], target = 10</p><p>输出：3</p><p>解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 &gt;，这是最接近 target 的方案。</p><p>示例 2：</p><p>输入：arr = [2,3,5], target = 10</p><p>输出：5</p><p>示例 3：</p><p>输入：arr = [60864,25176,27249,21296,20204], target = 56803</p><p>输出：11361</p></blockquote><p><strong>提示：</strong></p><ul><li>1 &lt;= arr.length &lt;= 10^4</li><li>1 &lt;= arr[i], target &lt;= 10^5</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>第一种思路就是<code>arr[i]</code>的取值范围<code>10^5</code>,可以直接穷举所有的数字，找到最接近target的值。</p><p>第二种思路就是确定value的取值范围为<code>[0,max(arr)]</code>设为阈值，则需要确定使得数组元素超过阈值的元素变为阈值后数组和的值最接近target，可通过二分查找出严格大于target的第一个阈值，在通过比较阈值与阈值-1的数组和，即可确定结果。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBestValue</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> len = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录前缀和</span></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= arr[len]; i++) &#123;</span><br><span class="line">            <span class="comment">//计算出小于i的前缀和</span></span><br><span class="line">            <span class="keyword">while</span>(arr[j] &lt; i)&#123;</span><br><span class="line">                pre += arr[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新最接近target的值</span></span><br><span class="line">            <span class="keyword">if</span>(Math.abs(pre + (len - j + <span class="number">1</span>) * i - target) &lt; min)&#123;</span><br><span class="line">                min = Math.abs(pre + (len - j + <span class="number">1</span>) * i - target);</span><br><span class="line">                num = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBestValue</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr)&#123;</span><br><span class="line">            right=Math.max(right,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(calSum(arr,mid)&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里left为第一个使数组和大于target的threshold</span></span><br><span class="line"><span class="comment">            则left-1必然使得数组和小于target，即判断这两个哪个接近target</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(target-calSum(arr,left-<span class="number">1</span>)&lt;=calSum(arr,left)-target)&#123;</span><br><span class="line">            <span class="keyword">return</span> left-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calSum</span><span class="params">(<span class="keyword">int</span>[]arr,<span class="keyword">int</span> threshold)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr)&#123;</span><br><span class="line">            sum+=Math.min(threshold,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;给你一个整数数组&lt;code&gt;arr&lt;/code&gt; 和一个目标值&lt;c
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-990-等式方程的可满足性</title>
    <link href="http://yoursite.com/2020/06/13/leetCode-990-%E7%AD%89%E5%BC%8F%E6%96%B9%E7%A8%8B%E7%9A%84%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7/"/>
    <id>http://yoursite.com/2020/06/13/leetCode-990-等式方程的可满足性/</id>
    <published>2020-06-13T00:39:26.000Z</published>
    <updated>2020-06-13T00:39:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：”a==b” 或”a!=b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p><p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回true，否则返回 false。</p><blockquote><p>示例 1：</p><p>输入：<code>[&quot;a==b&quot;,&quot;b!=a&quot;]</code></p><p>输出：false</p><p>解释：如果我们指定，a = 1 且 b = &gt;1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分&gt;配变量同时满足这两个方程。</p><p>示例 2：</p><p>输入：<code>[&quot;b==a&quot;,&quot;a==b&quot;]</code></p><p>输出：true</p><p>解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。</p><p>示例 3：</p><p>输入：<code>[&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]</code></p><p>输出：true</p></blockquote><p><strong>提示：</strong></p><ul><li>1 &lt;= equations.length &lt;= 500</li><li>equations[i].length == 4</li><li>equations[i][0] 和equations[i][3]是小写字母</li><li>equations[i][1] 要么是’=’，要么是’!’</li><li>equations[i][2]是’=’</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>问题的关键在于，怎么连通相等的元素，就是记录所有等价的元素，然后再去判断不等价关系中是否和前面记录的关系是否矛盾。</p><p>就是用并查集来统计，并查集特别巧妙的一点就是用数组下标代表该节点本身，值代表其指向的父节点，这样就表示了两个节点是相等的，通过将具有==关系的集合的两个节点全部关联起来，再去判断不等的关系。</p><p>并查集的优化：</p><ul><li><p>假如给定的数据是<code>[&quot;a==b&quot;,&quot;b==c&quot;,&quot;c==d&quot;,&quot;d==e&quot;]</code>,这样节点关系会变成一个链条，查找起来复杂度是O(n)级别的，如何优化那？主要有两种。</p></li><li><p>路径压缩：</p><ul><li><p>隔代压缩：就是将本节点指向的父节点改指向为父节点的父节点，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1               1</span><br><span class="line">|              / \    </span><br><span class="line">2   ---&gt;      2   3</span><br><span class="line">|</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li><li><p>完全压缩:将所有节点都指向父节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1                1</span><br><span class="line">|              / | \    </span><br><span class="line">2   ---&gt;      2  3  4</span><br><span class="line">|</span><br><span class="line">3</span><br><span class="line">|</span><br><span class="line">4</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>按秩合并：就是将树高度低的根结点，指向高的根结点，<a href="https://blog.csdn.net/ccsu_cherish/article/details/9750683" target="_blank" rel="noopener">https://blog.csdn.net/ccsu_cherish/article/details/9750683</a></li></ul><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//共26个节点</span></span><br><span class="line">        <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并所有==节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(equations[i].charAt(<span class="number">1</span>) == <span class="string">'='</span>)&#123;</span><br><span class="line">                union(equations[i].charAt(<span class="number">0</span>) -<span class="string">'a'</span>,equations[i].charAt(<span class="number">3</span>) - <span class="string">'a'</span>,parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断!=节点</span></span><br><span class="line">        <span class="keyword">for</span> (String equation : equations) &#123;</span><br><span class="line">            <span class="keyword">if</span>(equation.charAt(<span class="number">1</span>) == <span class="string">'!'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(find(equation.charAt(<span class="number">0</span>) - <span class="string">'a'</span>,parent) == find(equation.charAt(<span class="number">3</span>) - <span class="string">'a'</span>,parent))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并两个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> ch1,<span class="keyword">int</span> ch2,<span class="keyword">int</span>[] parent)</span></span>&#123;</span><br><span class="line">        parent[find(ch1,parent)] = find(ch2,parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> ch,<span class="keyword">int</span>[] parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent[ch] == ch ? ch :  find(parent[ch],parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-739-每日温度</title>
    <link href="http://yoursite.com/2020/06/12/leetCode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
    <id>http://yoursite.com/2020/06/12/leetCode-739-每日温度/</id>
    <published>2020-06-12T03:39:26.000Z</published>
    <updated>2020-06-12T03:39:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表<code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是<code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><p>提示：气温 列表长度的范围是<code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在<code>[30, 100]</code>范围内的整数。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>暴力思路是遍历数组T到第i个元素，然后找到距离i后面大于<code>T[i]</code>的元素，但是这样的时间复杂度是O(n^2)。</p><p>还有一种暴力思路，题目中气温的值是在<code>[30, 100]</code>范围内的整数，可以先把数组中所有的温度的下标保存起来，然后遍历温度列表的长度，在找到大于当前温度的最近的下标，这样相当于空间换时间，时间复杂度是O(mn)，m是气温的值的范围。</p><p>最后一种思路是单调栈，就是在遍历元素的时候，找到数组中当前元素之前大于当前元素的第一个元素，到当前元素的距离。问题是如何做到O(1)的时间找到数组中当前元素之前大于当前元素的第一个元素。就是用单调栈，当前元素与栈中元素比较，小则入栈，大则出栈并将二者之间的下标差值为出栈元素的结果值，并继续比较下一个栈顶元素，一直到栈为空，表示前面元素都找到了比自己大的值。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length; i++) &#123;</span><br><span class="line">            <span class="comment">//找到当前元素大于前一个元素的下标</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()])&#123;</span><br><span class="line">                Integer index = stack.pop();</span><br><span class="line">                res[index] = i - index;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-9-回文数</title>
    <link href="http://yoursite.com/2020/06/11/leetCode-9-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://yoursite.com/2020/06/11/leetCode-9-回文数/</id>
    <published>2020-06-11T05:38:26.000Z</published>
    <updated>2020-06-11T05:38:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><blockquote><p>示例 1:</p><p>输入: 121</p><p>输出: true</p><p>示例 2:</p><p>输入: -121</p><p>输出: false</p><p>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- &gt;。因此它不是一个回文数。</p><p>示例 3:</p><p>输入: 10</p><p>输出: false</p><p>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p></blockquote><p><strong>进阶:</strong></p><p>你能不将整数转为字符串来解决这个问题吗？</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>题目不让整数转为字符串，可以构造一个长度为int最大位数的数组来保存每一位上的数字，然后再去遍历数组，前后是否构成回文。</p><p>也可以直接反转这个数字，查看反转后的数字和原数字是否相等。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> reverseNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//int最大2147483647十位数字</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            nums[i++] = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断前后是否相等，不能判断到数组长度，需要判断到数字的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] != nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = x;</span><br><span class="line">        <span class="keyword">int</span> reverse = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//反转x</span></span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="number">0</span> )&#123;</span><br><span class="line">            reverse = reverse* <span class="number">10</span>+ temp % <span class="number">10</span>;</span><br><span class="line">            temp = temp/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverse == x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-39-组合总和</title>
    <link href="http://yoursite.com/2020/06/10/leetCode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <id>http://yoursite.com/2020/06/10/leetCode-39-组合总和/</id>
    <published>2020-06-10T04:33:26.000Z</published>
    <updated>2020-06-10T04:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>给定一个无重复元素的数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。</p><p>candidates中的数字可以无限制重复被选取。</p><p><strong>说明：</strong></p><p>所有数字（包括target）都是正整数。<br>解集不能包含重复的组合。</p><blockquote><p>示例1:</p><p>输入: candidates = [2,3,6,7], target = 7,</p><p>所求解集为:<br>[<br> [7],<br> [2,2,3]<br>]</p><p>示例 2:</p><p>输入: candidates = [2,3,5], target = 8,</p><p>所求解集为:<br>[<br>[2,2,2,2],<br>[2,3,3],<br>[3,5]<br>]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>最直接的思路就是暴力枚举每一种可能，因为每个元素都是可以无限制重复被选取，所以每个元素也可以重复选取。</p><p>但是上面做法会出现大量重复的结果，例如</p><ul><li>candidates = [2,3,6,7]，2,2,3是一种结果；</li><li>3,2,2也是一种结果。但是和前面那种结果是重复的。</li></ul><p>怎么去除这些重复的子集那？解决的办法就是将数组排序，这样在进行递归的时候，从当前元素到大于当前元素的数字枚举，这样就不会出现重复子集。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(candidates,target,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> index,List&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            <span class="comment">//数组是递增的  小于零的情况直接结束</span></span><br><span class="line">            <span class="keyword">if</span>(target - candidates[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            dfs(candidates,target - candidates[i],i,path);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;给定一个无重复元素的数组candidates和一个目标数targe
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-126-单词接龙II</title>
    <link href="http://yoursite.com/2020/06/09/leetCode-126-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99II/"/>
    <id>http://yoursite.com/2020/06/09/leetCode-126-单词接龙II/</id>
    <published>2020-06-09T04:33:26.000Z</published>
    <updated>2020-06-09T04:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：</p><ul><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。</li></ul><p><strong>说明:</strong></p><ul><li>如果不存在这样的转换序列，返回一个空列表。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li></ul><blockquote><p>示例 1:</p><p>输入:</p><p>beginWord = “hit”,</p><p>endWord = “cog”,</p><p>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p><p>输出:<br>[<br> [“hit”,”hot”,”dot”,”dog”,”cog”],<br>[“hit”,”hot”,”lot”,”log”,”cog”]<br>]</p><p>示例 2:</p><p>输入:</p><p>beginWord = “hit”</p><p>endWord = “cog”</p><p>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]</p><p>输出: []</p><p>解释: endWord “cog” </p><p>不在字典中，所以不存在符合要求的转换序列。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>第一种思路就是用dfs暴力配合回溯枚举每一种可能到达答案的可能，但是这样做时间复杂度是指数级别的，虽然加上适当的剪枝，但还是超时了。</p><p>第二种思路是BFS直接复制某大佬的解法，自己再用bfs解决问题的时候，主要遇到两个问题。</p><ul><li>第一是如何保存路径(结果集里面需要返最短的路径)，在遍历的时候，可以直接在队列里面保存遍历的路径(而不是保存遍历到的单词)，这样在元素出队的时候直接拿到路径中最后一个元素就是当前需要处理的单词。这时候再去寻找该单词的下一个符合条件的单词。<ul><li>如果查找的单词符合条件，但是不是最终结果：将该路径添加到路径的后面，重新加入队列，继续查找。</li><li>如果查找的单词符合条件，是最终结果查询则截止到该层。加入结果集。</li></ul></li></ul><ul><li>第二在用DFS判断两个单词是否可以相互转换的时候，是直接遍历两个单词来检验是否相等，但是这样做不仅效率低，而且会有大量的重复判断计算。可以先把单词保存到一个set集合中，然后依次更换当前单词的每个字符，再去set集合中查询是否存在。这样做的好处是，只需要遍历一遍这个单词和遍历26个替换的字母就可以查询到当前单词何以转换的所有情况，时间复杂度上是O(26*单词长度)的。但是上面那种遍历的方式是依次比较所有的单词，时间复杂度是O(单词长度 * wordList长度)，当wordList里面单词个数很多就比较耗时。</li></ul><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><p>超时DFS:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line">    <span class="comment">//保存最小结果的长度</span></span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[wordList.size()];</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(beginWord);</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">        dfs(beginWord, endWord, wordList, visited, list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList, <span class="keyword">boolean</span>[] visited, List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//剪枝，大于已知最小长度结果退出</span></span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt; min) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保存路径并更新最短路径</span></span><br><span class="line">        <span class="keyword">if</span> (beginWord.equals(endWord)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.size() &gt; <span class="number">0</span> &amp;&amp; list.size() &lt; res.get(<span class="number">0</span>).size())&#123;</span><br><span class="line">                min = list.size();</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            min = list.size();</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">//查找符合条件的单词</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[i] &amp;&amp; check(beginWord, wordList.get(i))) &#123;</span><br><span class="line">                list.add(wordList.get(i));</span><br><span class="line">                visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(wordList.get(i), endWord, wordList, visited, list);</span><br><span class="line">                <span class="comment">//回溯到上一步</span></span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">                visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//差异一个字母的单词</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i) != s2.charAt(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BFS:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        <span class="comment">// 结果集</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; distSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        <span class="comment">// 字典中不包含目标单词</span></span><br><span class="line">        <span class="keyword">if</span> (!distSet.contains(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经访问过的单词集合：只找最短路径，所以之前出现过的单词不用出现在下一层</span></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 累积每一层的结果队列</span></span><br><span class="line">        Queue&lt;List&lt;String&gt;&gt; queue= <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(beginWord));</span><br><span class="line">        queue.add(list);</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line">        <span class="comment">// 是否到达符合条件的层：如果该层添加的某一单词符合目标单词，则说明截止该层的所有解为最短路径，停止循环</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; !flag) &#123;</span><br><span class="line">            <span class="comment">// 上一层的结果队列</span></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="comment">// 该层添加的所有元素：每层必须在所有结果都添加完新的单词之后，再将这些单词统一添加到已使用单词集合</span></span><br><span class="line">            <span class="comment">// 如果直接添加到 visited 中，会导致该层本次结果添加之后的相同添加行为失败</span></span><br><span class="line">            <span class="comment">// 如：该层遇到目标单词，有两条路径都可以遇到，但是先到达的将该单词添加进 visited 中，会导致第二条路径无法添加</span></span><br><span class="line">            Set&lt;String&gt; subVisited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                List&lt;String&gt; path = queue.poll();</span><br><span class="line">                <span class="comment">// 获取该路径上一层的单词</span></span><br><span class="line">                String word = path.get(path.size() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">                <span class="comment">// 寻找该单词的下一个符合条件的单词</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; chars.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">char</span> temp = chars[j];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ch++) &#123;</span><br><span class="line">                        chars[j] = ch;</span><br><span class="line">                        <span class="keyword">if</span> (temp == ch) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        String str = <span class="keyword">new</span> String(chars);</span><br><span class="line">                        <span class="comment">// 符合条件：在 wordList 中 &amp;&amp; 之前的层没有使用过</span></span><br><span class="line">                        <span class="keyword">if</span> (distSet.contains(str) &amp;&amp; !visited.contains(str)) &#123;</span><br><span class="line">                            <span class="comment">// 生成新的路径</span></span><br><span class="line">                            List&lt;String&gt; pathList = <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">                            pathList.add(str);</span><br><span class="line">                            <span class="comment">// 如果该单词是目标单词：将该路径添加到结果集中，查询截止到该层</span></span><br><span class="line">                            <span class="keyword">if</span> (str.equals(endWord)) &#123;</span><br><span class="line">                                flag = <span class="keyword">true</span>;</span><br><span class="line">                                res.add(pathList);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 将该路径添加到该层队列中</span></span><br><span class="line">                            queue.add(pathList);</span><br><span class="line">                            <span class="comment">// 将该单词添加到该层已访问的单词集合中</span></span><br><span class="line">                            subVisited.add(str);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    chars[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将该层所有访问的单词添加到总的已访问集合中</span></span><br><span class="line">            visited.addAll(subVisited);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;给定两个单词（beginWord 和 endWord）和一个字典 
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-128-最长连续序列</title>
    <link href="http://yoursite.com/2020/06/08/leetCode-128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/06/08/leetCode-128-最长连续序列/</id>
    <published>2020-06-08T03:33:26.000Z</published>
    <updated>2020-06-08T03:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p><p>要求算法的时间复杂度为 O(n)。</p><blockquote><p>示例:</p><p>输入: [100, 4, 200, 1, 3, 2]</p><p>输出: 4</p><p>解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>题目要求时间复杂度是O(n),所以不能用排序，这时候一个思路就是拿空间换时间，可以把所有的数字存到set里，再去遍历所有数字，依次找到所有小于他的连续数字的长度。</p><p>但是作为一个hard难度的问题，前面的解法并不算太好的解法，时间复杂度上，最好是O(n),最坏还是会达到O(n^2)的，所以不是严格意义上的O(n)。</p><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//先把所有的元素加入集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(num - <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//一直找到不连续的数字</span></span><br><span class="line">                <span class="keyword">while</span>(set.contains(num - <span class="number">1</span>))&#123;</span><br><span class="line">                    num += <span class="number">1</span>;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                res = Math.max(res,count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#8B475D&quot;&gt;题目描述&lt;/font&gt;&lt;/h2&gt;&lt;p&gt;给定一个未排序的整数数组，找出最长连续序列的长度。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
