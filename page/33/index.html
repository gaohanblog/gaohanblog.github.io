<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2">



















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/ffavicon32.ico?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon32.ico?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":15,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>



  <meta name="description" content="闲敲棋子落灯花">
<meta property="og:type" content="website">
<meta property="og:title" content="To be or not to be?">
<meta property="og:url" content="http://yoursite.com/page/33/index.html">
<meta property="og:site_name" content="To be or not to be?">
<meta property="og:description" content="闲敲棋子落灯花">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="To be or not to be?">
<meta name="twitter:description" content="闲敲棋子落灯花">



  <link rel="alternate" href="/atom.xml" title="To be or not to be?" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://yoursite.com/page/33/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>To be or not to be?</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">To be or not to be?</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">gaohan的学习小栈</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>about me</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



</div>
    </header>

    
  
  

  

  <a href="https://github.com/gaohanblog/gaohanblog.github.io" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/30/08-JDK动态代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="96gh'home">
      <meta itemprop="description" content="闲敲棋子落灯花">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/30/08-JDK动态代理/" class="post-title-link" itemprop="url">08-JDK动态代理</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-30 09:36:48" itemprop="dateCreated datePublished" datetime="2019-01-30T09:36:48+08:00">2019-01-30</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-15 11:28:48" itemprop="dateModified" datetime="2019-11-15T11:28:48+08:00">2019-11-15</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">2.9k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">3 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>代理模式是一个很重要的模式，在我的设计模式文章里面也有关于代理模式的分析，上篇文章我们看了注解，如果在<code>spring</code>中最典型的两个特性一个是<code>IOC</code>即控制反转和<code>AOP</code>即面向切面编程，<code>IOC</code>的实现原理是利用了<code>JAVA</code>的反射技术，那么<code>AOP</code>的实现原理是什么呢？就是动态代理技术，目前动态代理技术主要分为<code>Java</code>自己提供的<code>JDK</code>动态代理技术和<code>CGLIB</code>技术,下面我们看下“JDK的动态代理技术”</p>
<h2 id="代理模式的定义"><a href="#代理模式的定义" class="headerlink" title=" 代理模式的定义"></a><font color="#8B475D"> 代理模式的定义</font></h2><p>定义：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。</p>
<ul>
<li><code>RealSubject</code> 是原对象（本文把原对象称为”委托对象”），<code>Proxy</code> 是代理对象。</li>
<li><code>Subject</code> 是委托对象和代理对象都共同实现的接口。</li>
<li><code>Request()</code> 是委托对象和代理对象共同拥有的方法。</li>
</ul>
<p>举个栗子，生活中我们购买火车票可以去火车站买，但是也可以去火车票代售处买，此处的火车票代售处就是火车站购票的代理，即我们在代售点发出买票请求，代售点会把请求发给火车站，火车站把购买成功响应发给代售点，代售点再告诉你。</p>
<p>但是代售点只能买票，不能退票，而火车站能买票也能退票，因此代理对象支持的操作可能和委托对象的操作有所不同。</p>
<h2 id="Java实现静态代理示例"><a href="#Java实现静态代理示例" class="headerlink" title=" Java实现静态代理示例"></a><font color="#8B475D"> Java实现静态代理示例</font></h2><p><img src="http://blog-picture-g.test.upcdn.net/javaBasic/javabasic8-1.png" alt="image"></p>
<p>代理的实现分为：</p>
<ul>
<li>静态代理</li>
</ul>
<p>代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 class 文件。    </p>
<ul>
<li>动态代理</li>
</ul>
<p>代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 class 文件，而是在运行时动态生成的类字节码，并加载到JVM中。 </p>
<h2 id="Java-实现动态代理"><a href="#Java-实现动态代理" class="headerlink" title=" Java 实现动态代理"></a><font color="#8B475D"> Java 实现动态代理</font></h2><p>几个重要名词:</p>
<h5 id="几个重要名词"><a href="#几个重要名词" class="headerlink" title="#几个重要名词:"></a>#<font color="#367bdd">几个重要名词:</font></h5><ul>
<li>委托类和委托对象：委托类是一个类，委托对象是委托类的实例，即原类。</li>
<li>代理类和代理对象：代理类是一个类，代理对象是代理类的实例。</li>
</ul>
<h5 id="Java实现动态代理的大致步骤如下："><a href="#Java实现动态代理的大致步骤如下：" class="headerlink" title="#Java实现动态代理的大致步骤如下："></a>#<font color="#367bdd">Java实现动态代理的大致步骤如下：</font></h5><ul>
<li>定义一个委托类和公共接口。</li>
<li>自己定义一个类（调用处理器类，即实现 InvocationHandler 接口），这个类的目的是指定运行时将生成的代理类需要完成的具体任务（包括Preprocess和Postprocess），即代理类调用任何方法都会经过这个调用处理器类（在本文最后一节对此进行解释）。</li>
<li>生成代理对象（当然也会生成代理类），需要为他指定(1)类加载器对象(2)实现的一系列接口(3)调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器实例。</li>
</ul>
<h5 id="Java-实现动态代理主要涉及以下几个类"><a href="#Java-实现动态代理主要涉及以下几个类" class="headerlink" title="#Java 实现动态代理主要涉及以下几个类:"></a>#<font color="#367bdd">Java 实现动态代理主要涉及以下几个类:</font></h5><ul>
<li><code>java.lang.reflect.Proxy</code>: 这是生成代理类的主类，通过 <code>Proxy</code> 类生成的代理类都继承了 <code>Proxy</code> 类，即 <code>DynamicProxyClass extends Proxy</code>。</li>
<li><code>java.lang.reflect.InvocationHandler</code>: 这里称他为”调用处理器”，他是一个接口，我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 <code>InvocationHandler</code> 接口。</li>
</ul>
<h5 id="Proxy-类主要方法为："><a href="#Proxy-类主要方法为：" class="headerlink" title="#Proxy 类主要方法为："></a>#<font color="#367bdd">Proxy 类主要方法为：</font></h5><p><img src="http://blog-picture-g.test.upcdn.net/javaBasic/javabasic8-2.png" alt="image"></p>
<ul>
<li>这个静态函数的第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM 的方法区）</li>
<li>第二个参数是接口（表明你这个代理类需要实现哪些接口）</li>
<li>第三个参数是调用处理器类实例（指定代理类中具体要干什么）。</li>
<li>这个函数是 JDK 为了程序员方便创建代理对象而封装的一个函数，因此你调用<code>newProxyInstance()</code>时直接创建了代理对象（略去了创建代理类的代码）。其实他主要完成了以下几个工作：</li>
</ul>
<p><img src="http://blog-picture-g.test.upcdn.net/javaBasic/javabasic8-3.png" alt="image"></p>
<p><code>Proxy</code> 类还有一些静态方法，比如：</p>
<ul>
<li><code>InvocationHandler getInvocationHandler(Object proxy)</code>: 获得代理对象对应的调用处理器对象。</li>
<li><code>Class getProxyClass(ClassLoader loader, Class[] interfaces)</code>: 根据类加载器和实现的接口获得代理类。</li>
</ul>
<p><code>Proxy</code> 类中有一个映射表，映射关系为：<code>(&lt;ClassLoader&gt;,(&lt;Interfaces&gt;,&lt;ProxyClass&gt;) )</code>，可以看出一级key为类加载器，根据这个一级key获得二级映射表，二级key为接口数组，因此可以看出：一个类加载器对象和一个接口数组确定了一个代理类。</p>
<p>我们写一个简单的例子来阐述 Java 实现动态代理的整个过程：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/javaBasic/javabasic8-4.png" alt="image"></p>
<p><code>InvocationHandler</code> 接口中有方法：<code>invoke(Object proxy, Method method, Object[] args)</code></p>
<p>这个函数是在代理对象调用任何一个方法时都会调用的，方法不同会导致第二个参数method不同，<strong>第一个参数是代理对象</strong>（表示哪个代理对象调用了method方法，传递来的是），<strong>第二个参数是 Method</strong> 对象（表示哪个方法被调用了），<strong>第三个参数是指定调用方法的参数。</strong></p>
<p>动态生成的代理类具有几个特点：</p>
<ul>
<li>继承 <code>Proxy</code> 类，并实现了在<code>Proxy.newProxyInstance()</code>中提供的接口数组。</li>
<li><code>public final</code>。</li>
<li>命名方式为 <code>$ProxyN</code>，其中N会慢慢增加，一开始是 <code>$Proxy1</code>，接下来是<code>$Proxy2…</code>带有<code>$</code>符号的对象就是在程序运行时动态生成的对象。</li>
<li>有一个参数为 <code>InvocationHandler</code> 的构造函数。这个从 <code>Proxy.newProxyInstance()</code> 函数内部的<code>clazz.getConstructor(new Class[] { InvocationHandler.class })</code> 可以看出。</li>
</ul>
<p>Java 实现动态代理的缺点：因为 Java 的单继承特性（每个代理类都继承了<code>Proxy</code> 类），只能针对接口创建代理类，不能针对类创建代理类。</p>
<h5 id="一个小栗子来看动态代理全过程"><a href="#一个小栗子来看动态代理全过程" class="headerlink" title="#一个小栗子来看动态代理全过程"></a>#<font color="#367bdd">一个小栗子来看动态代理全过程</font></h5><p>假设模拟一个场景，买衣服，正常情况所有人买这件衣服要100块钱。</p>
<p>定义一个销售接口：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/javaBasic/javabasic8-5.png" alt="image"></p>
<p>一个具体的实现类：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/javaBasic/javabasic8-6.png" alt="image"></p>
<p>那么正常情况大家都要花100才能买这件衣服。但是现在对会员做活动，会员打5折。怎么做呢？正常思维是：增加一个接口，甚至更糟的想法是修改一下这个实现类，都是不好的，那么我们是否想过这样的方案：新建一个新的类，让这个代理类去做相应的逻辑呢？既不用修改原来的代码，而且还很简单就能实现。</p>
<p>现在写一个代理类：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/javaBasic/javabasic8-7.png" alt="image"></p>
<p>那么调用的时候，一个是会员，一个是普通用户，根据身份调不同的方法即可：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/javaBasic/javabasic8-8.png" alt="image"></p>
<h2 id="Java-动态代理的内部实现"><a href="#Java-动态代理的内部实现" class="headerlink" title="Java 动态代理的内部实现"></a><font color="#8B475D">Java 动态代理的内部实现</font></h2><p>现在我们就会有一个问题： <code>Java</code> 是怎么保证代理对象调用的任何方法都会调用 <code>InvocationHandler</code> 的 <code>invoke()</code> 方法的？</p>
<p>这就涉及到动态代理的内部实现。假设有一个接口 <code>Subject</code>，且里面有 <code>int request(int i)</code> 方法，则生成的代理类大致如下：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/javaBasic/javabasic8-9.png" alt="image"></p>
<p>通过上面的方法就成功调用了 <code>invoke()</code>方法，所以这是代理类中已经注定要去执行 <code>invoke()</code> 方法了。</p>
<p>这有一篇写的比较生动的阐述了动态代理的含义<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513926&idx=1&sn=1c43c5557ba18fed34f3d68bfed6b8bd&chksm=80d67b85b7a1f2930ede2803d6b08925474090f4127eefbb267e647dff11793d380e09f222a8#rd" target="_blank" rel="noopener">Java帝国之动态代理</a></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/26/07-基础核心知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="96gh'home">
      <meta itemprop="description" content="闲敲棋子落灯花">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/26/07-基础核心知识点/" class="post-title-link" itemprop="url">07-基础核心知识点</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-26 18:35:48" itemprop="dateCreated datePublished" datetime="2019-01-26T18:35:48+08:00">2019-01-26</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-13 11:26:48" itemprop="dateModified" datetime="2019-11-13T11:26:48+08:00">2019-11-13</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">10k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">9 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>主要针对Java基础的核心知识点，基础只是一个引子，本篇文章中每个知识点背后的问题都需要我们深入挖掘。不能忽略对他们的复习。</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a><font color="#8B475D">关键字</font></h2><h5 id="final"><a href="#final" class="headerlink" title="#final"></a>#<font color="#367bdd">final</font></h5><ol>
<li><p>数据类型</p>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<ul>
<li>对于基本类型，<code>final</code> 使数值不变；</li>
<li>对于引用类型，<code>final</code> 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// x = 2;  // cannot assign value to final variable 'x'</span></span><br><span class="line"><span class="keyword">final</span> A y = <span class="keyword">new</span> A();</span><br><span class="line">y.a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>方法</li>
</ol>
<p>声明方法不能被子类覆盖。</p>
<p><code>private</code> 方法隐式地被指定为 <code>final</code>，如果在子类中定义的方法和基类中的一个 <code>private</code> 方法签名相同，此时子类的方法不是覆盖基类方法，而是在子类中定义了一个新的方法。</p>
<ol start="3">
<li>类</li>
</ol>
<p>声明类不允许被继承。</p>
<h5 id="static"><a href="#static" class="headerlink" title="#static"></a>#<font color="#367bdd">static</font></h5><ol>
<li>静态变量</li>
</ol>
<p>静态变量在内存中只存在一份，只在类初始化时赋值一次。</p>
<ul>
<li>静态变量：类所有的实例都共享静态变量，可以直接通过类名来访问它；</li>
<li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>
<ol start="2">
<li>静态方法</li>
</ol>
<p>静态方法在类加载的时候就存在了，它不依赖于任何实例，所以静态方法必须有实现，也就是说它不能是抽象方法（<code>abstract</code>）。</p>
<ol start="3">
<li>静态语句块</li>
</ol>
<p>静态语句块在类初始化时运行一次。</p>
<ol start="4">
<li>静态内部类</li>
</ol>
<p>内部类的一种，静态内部类不依赖外部类，且不能访问外部类的非静态的变量和方法。</p>
<ol start="5">
<li>静态导包</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure>

<p>在使用静态变量和方法时不用再指明 <code>ClassName</code>，从而简化代码，但可读性大大降低。</p>
<ol start="6">
<li>变量赋值顺序</li>
</ol>
<p>静态变量的赋值和静态语句块的运行优先于实例变量的赋值和普通语句块的运行，静态变量的赋值和静态语句块的运行哪个先执行取决于它们在代码中的顺序。</p>
<p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
<h2 id="Object-通用方法"><a href="#Object-通用方法" class="headerlink" title="Object 通用方法"></a><font color="#8B475D">Object 通用方法</font></h2><h5 id="面向对象的起源Object"><a href="#面向对象的起源Object" class="headerlink" title="#面向对象的起源Object"></a>#<font color="#367bdd">面向对象的起源Object</font></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="equals"><a href="#equals" class="headerlink" title="#equals()"></a>#<font color="#367bdd">equals()</font></h5><ol>
<li>equals() 与 == 的区别<ul>
<li>对于基本类型，<code>==</code> 判断两个值是否相等，基本类型没有 <code>equals()</code> 方法。</li>
<li>对于引用类型，<code>==</code> 判断两个实例是否引用同一个对象，而 <code>equals()</code> 判断引用的对象是否等价。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>默认情况下也就是从超类<code>Object</code>继承而来的<code>equals</code>方法与<code>==</code>是完全等价的，比较的都是对象的内存地址，但我们可以重写<code>equals</code>方法，使其按照我们的需求的方式进行比较，如<code>String</code>类重写了<code>equals</code>方法，使其比较的是字符的序列，而不再是内存地址。</p>
<ol start="2">
<li>等价关系</li>
</ol>
<p>（一）自反性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>（二）对称性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>（三）传递性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>

<p>（四）一致性</p>
<p>多次调用 equals() 方法结果不变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>（五）与 <code>null</code> 的比较<br>对任何不是 <code>null</code> 的对象 x 调用 <code>x.equals(null)</code> 结果都为 <code>false</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.euqals(<span class="keyword">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>实现<ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 实例进行转型；</li>
<li>判断每个关键域是否相等。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EqualExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="keyword">null</span> || <span class="keyword">this</span>.getClass() != obj.getClass())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        EqualExample that = (EqualExample)obj;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.x != that.x || <span class="keyword">this</span>.y != that.y || <span class="keyword">this</span>.z != that.z)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a><font color="#8B475D">hashCode()</font></h2><p> <code>hasCode()</code> 返回散列值，而 <code>equals()</code> 是用来判断两个实例是否等价。等价的两个实例散列值一定要相同，但是散列值相同的两个实例不一定等价。</p>
<p> 下面的代码中，新建了两个等价的实例，并将它们添加到 <code>HashSet</code> 中。我们希望将这两个实例当成一样的，只在集合中添加一个实例，但是因为 <code>EqualExample</code> 没有实现 <code>hasCode()</code> 方法，因此这两个实例的散列值是不同的，最终导致集合添加了两个等价的实例。</p>
<p> <img src="http://blog-picture-g.test.upcdn.net/javaBasic/javaBasic7-1.png" alt="image"></p>
<p> 等价的两个实例<code>hashcode</code>一定相同,为什么<code>equals</code>方法不相等而<code>HashCode</code>方法返回的值却有可能相同呢？</p>
<blockquote>
<p>HashCode方法实际上是通过一种算法得到一个对象的hash码，这个hash码是用来确定该对象在哈希表中具体的存储区域的。返回的hash码是int类型的所以它的数值范围为[-2147483648-+2147483647]之间的，而超过这个范围，实际会产生溢出，溢出之后的值实际在计算机中存的也是这个范围的。比如最大值2147483647+1之后并不是在计算机中不存储了，它实际在计算机中存储的是-2147483648。在java中对象可以有很多很多通过new关键字来产生。而hash码也是通过特定算法得到的，所以很难或者说几乎没有什么算法在这个范围内在这个情况下不会不产生相同的hash码的。也就是说在上述情况下肯定是会发生哈希碰撞的，因此不同对象可能有相同的HashCode的返回值。也有人说Object方法中的HashCode方法是通过内存地址得来的，是唯一的。可是HashCode方法是共有的，也就意味着它是可以被重写的。因此不同环境下实现HashCode的算法可能不同。因此equals方法返回结果不相等，而HashCode方法返回的值却有可能相同！</p>
</blockquote>
<h5 id="clone"><a href="#clone" class="headerlink" title="#clone()"></a>#<font color="#367bdd">clone()</font></h5><ol>
<li>cloneable</li>
</ol>
<p><code>clone()</code> 是 <code>Object</code> 的受保护方法，这意味着，如果一个类不显式去覆盖 <code>clone()</code> 就没有这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">    CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"><span class="comment">// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object' </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来覆盖 <code>Object</code> 的 <code>clone()</code><br>得到以下实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> CloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (CloneExample)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    CloneExample e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">java.lang.CloneNotSupportedException: CloneTest</span><br></pre></td></tr></table></figure>

<p>以上抛出了 <code>CloneNotSupportedException</code>，这是因为 如果需要重写<code>colne</code>方法需要这个实现 Cloneable 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该注意的是，<code>clone()</code> 方法并不是 <code>Cloneable</code> 接口的方法，而是 <code>Object</code> 的一个 <code>protected</code> 方法。<code>Cloneable</code> 接口只是规定，如果一个类没有实现 <code>Cloneable</code> 接口又调用了 <code>clone()</code> 方法，就会抛出 <code>CloneNotSupportedException</code>。</p>
<ol start="2">
<li>深拷贝与浅拷贝<ul>
<li>浅拷贝：拷贝实例和原始实例的引用类型引用同一个对象；</li>
<li>深拷贝：拷贝实例和原始实例的引用类型引用不同对象。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShallowCloneExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ShallowCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ShallowCloneExample) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ShallowCloneExample e1 = <span class="keyword">new</span> ShallowCloneExample();</span><br><span class="line">ShallowCloneExample e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//深拷贝</span><br><span class="line">public class DeepCloneExample implements Cloneable &#123;</span><br><span class="line">    private int[] arr;</span><br><span class="line"></span><br><span class="line">    public DeepCloneExample() &#123;</span><br><span class="line">        arr = new int[10];</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(int index, int value) &#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int get(int index) &#123;</span><br><span class="line">        return arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected DeepCloneExample clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        DeepCloneExample result = (DeepCloneExample) super.clone();</span><br><span class="line">        result.arr = new int[arr.length];</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            result.arr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在浅拷贝中，基本数据类型是值传递，所以修改值后不会影响另一个对象的该属性值；</p>
<p>引用数据类型是地址传递（引用传递），所以修改值后另一个对象的该属性值会同步被修改。</p>
<p><code>String</code>类型非常特殊，首先，<code>String</code>类型属于引用数据类型，不属于基本数据类型，但是<code>String</code>类型的数据是存放在常量池中的，也就是无法修改的！也就是说，当我们在原始对象里面修改了字符串的指向并不是修改了这个数据的值，而是把这个数据的引用从指向新的字符常量。在这种情况下，拷贝类型所指向的还是原来的字符常量。</p>
<p>在深拷贝中不同于浅拷贝，他把原有对象的基本类型和引用类型都进行了改变，使得拷贝对象的引用类型指向和原始类型的指向不指向同一个对象。</p>
<p>关于深拷贝和浅拷贝内容很多，所以不在这里一一赘述了。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a><font color="#8B475D">继承</font></h2><h5 id="访问权限"><a href="#访问权限" class="headerlink" title="#访问权限"></a>#<font color="#367bdd">访问权限</font></h5><p>Java 中有三个访问权限修饰符：<code>private</code>、<code>default</code>、<code>protected</code> 以及public，如果不加访问修饰符，表示包级可见。</p>
<p>可以对类或类中的成员（字段以及方法）加上访问修饰符。</p>
<ul>
<li>成员可见表示其它类可以用这个类的实例访问到该成员；</li>
<li>类可见表示其它类可以用这个类创建对象。</li>
</ul>
<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p>
<p>如果子类的方法覆盖了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p>
<p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。可以使用公有的 <code>getter</code> 和 <code>setter</code> 方法来替换公有字段。</p>
<h5 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="#抽象类与接口"></a>#<font color="#367bdd">抽象类与接口</font></h5><ol>
<li>抽象类</li>
</ol>
<p>抽象类和抽象方法都使用 abstract 进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</p>
<p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p>
<ol start="2">
<li>接口<br>接口的成员（字段 + 方法）默认都是 <code>public</code> 的，并且不允许定义为 <code>private</code> 或者<code>protected</code>。</li>
</ol>
<p>接口的字段默认都是 static 和 final 的。</p>
<p>下面是我在尝试过程中，编译器爆出的警告。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">123</span>;</span><br><span class="line">    <span class="comment">// int y;                // Variable 'y' might not have been initialized</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> z = <span class="number">0</span>;       <span class="comment">// Modifier 'public' is redundant for interface fields</span></span><br><span class="line">    <span class="comment">// private int k = 0;   // Modifier 'private' not allowed here</span></span><br><span class="line">    <span class="comment">// protected int l = 0; // Modifier 'protected' not allowed here</span></span><br><span class="line">    <span class="comment">// private void fun3(); // Modifier 'private' not allowed here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>比较</p>
<ul>
<li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。(在实际开发中接口更像一种契约，一旦设计基本上禁止修改，所以对接口设计要求很严格)</li>
<li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>
<li>接口的字段只能是 <code>static</code> 和 <code>final</code> 类型的，而抽象类的字段没有这种限制。</li>
<li>接口的方法只能是 <code>public</code> 的，而抽象类的方法可以由多种访问权限。</li>
</ul>
</li>
</ol>
<h5 id="super"><a href="#super" class="headerlink" title="#super"></a>#<font color="#367bdd">super</font></h5><ul>
<li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而完成一些初始化的工作。</li>
<li>访问父类的成员：如果子类覆盖了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"FatherExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildrenExample</span> <span class="keyword">extends</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildrenExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.func();</span><br><span class="line">        System.out.println(<span class="string">"ChildrenExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperExample.func()</span><br><span class="line">ChildrenExample.func()</span><br></pre></td></tr></table></figure>

<h5 id="覆盖与重载"><a href="#覆盖与重载" class="headerlink" title="#覆盖与重载"></a>#<font color="#367bdd">覆盖与重载</font></h5><ul>
<li><p>覆盖（<code>Override</code>）存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法；</p>
</li>
<li><p>重载（<code>Overload</code>）存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。应该注意的是，返回值不同，其它都相同不算是重载。</p>
</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a><font color="#8B475D">String</font></h2><h5 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="#String, StringBuffer and StringBuilder"></a>#<font color="#367bdd">String, StringBuffer and StringBuilder</font></h5><ol>
<li><p>是否可变</p>
<ul>
<li><code>String</code> 不可变</li>
<li><code>StringBuffer</code> 和 <code>StringBuilder</code> 可变</li>
</ul>
</li>
<li><p>是否线程安全</p>
<ul>
<li><code>String</code> 不可变，因此是线程安全的</li>
<li><code>StringBuilder</code> 不是线程安全的</li>
<li><code>StringBuffer</code> 是线程安全的，内部使用锁 <code>synchronized</code> 来同步</li>
</ul>
</li>
</ol>
<h5 id="String-intern"><a href="#String-intern" class="headerlink" title="#String.intern()"></a>#<font color="#367bdd">String.intern()</font></h5><p>使用 <code>String.intern()</code> 可以保证相同内容的字符串实例引用相同的内存对象。</p>
<p>下面示例中，<code>s1</code> 和 <code>s2</code> 采用 <code>new String()</code> 的方式新建了两个不同对象，而 <code>s3</code> 是通过 <code>s1.intern()</code> 方法取得一个对象引用，这个方法首先把 <code>s1</code> 引用的对象放到 <code>String Poll</code>（字符串常量池）中，然后返回这个对象引用。因此 <code>s3</code> 和 <code>s1</code> 引用的是同一个字符串常量池的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">System.out.println(s1.intern() == s3);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 <figure class="highlight plain"><figcaption><span>Pool``` 中。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">String s4 = &quot;bbb&quot;;</span><br><span class="line">String s5 = &quot;bbb&quot;;</span><br><span class="line">System.out.println(s4 == s5);  // true</span><br></pre></td></tr></table></figure></p>
<h2 id="基本类型与运算"><a href="#基本类型与运算" class="headerlink" title="基本类型与运算"></a><font color="#8B475D">基本类型与运算</font></h2><h5 id="包装类型"><a href="#包装类型" class="headerlink" title="#包装类型"></a>#<font color="#367bdd">包装类型</font></h5><p>八个基本类型：</p>
<ul>
<li>boolean/1</li>
<li>byte/8</li>
<li>char/16</li>
<li>short/16</li>
<li>int/32</li>
<li>float/32</li>
<li>long/64</li>
<li>double/64</li>
</ul>
<p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成,关于拆箱和自动装箱，可以看第一篇的文章。</p>
<p>在<code>Intger</code>关于缓冲池中的对象，其他地方也有类似的例子：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F<br>因此在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/22/06-反射/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="96gh'home">
      <meta itemprop="description" content="闲敲棋子落灯花">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/22/06-反射/" class="post-title-link" itemprop="url">06-反射</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-22 18:35:48" itemprop="dateCreated datePublished" datetime="2019-01-22T18:35:48+08:00">2019-01-22</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-13 09:22:48" itemprop="dateModified" datetime="2019-11-13T09:22:48+08:00">2019-11-13</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">4.2k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">4 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>反射的用处非常多，也非常强大，在很多流行框架Spring和Mybatis等框架我们都可以看到反射的身影，下面让我们来彻底了解下反射原理。</p>
<h2 id="反射的定义"><a href="#反射的定义" class="headerlink" title="反射的定义"></a><font color="#8B475D">反射的定义</font></h2><p>反射机制是在<strong>运行状态中</strong>，对于任意一个类，都能知道所有属性和方法；对于任意一个对象，都能调用他的任意一个方法，这种动态获取信息及调用对象的方法的功能就叫反射。</p>
<h2 id="jvm如何加载一个类"><a href="#jvm如何加载一个类" class="headerlink" title="jvm如何加载一个类"></a><font color="#8B475D">jvm如何加载一个类</font></h2><p>我们知道java语言是运行在JVM上面的，我们编写代码的时候，经过编译器编译以后会产生对应的<code>.class</code>文件，也就是JVM可以执行加载的字节码文件。</p>
<p>在程序运行期间，当JVM发现需要实例化一个类，它是如何把这个类加载到内存中去的呢，首先JVM会先看内存中是否有这个类，如果有的话，直接实例化这个类。如果没有JVM就会根据类名去加载这个类，当加载一个类，或者当加载器<code>class loader</code>的<code>definaeClass</code>被JVM调用，便会产生一个<code>Class</code>对象（一个<code>Class</code>类的实例）,用来表达这个类，<strong>该类所有的实例都共同拥有者这个<code>Class</code>对象，而且是全局唯一的。</strong></p>
<p>也就是说，加载<code>.class</code>文件之后会生成一个对应的<code>Class</code>对象。下面说说如何获取这个<code>Class</code>对象。</p>
<h2 id="获取Class对象的三种方式"><a href="#获取Class对象的三种方式" class="headerlink" title="获取Class对象的三种方式"></a><font color="#8B475D">获取Class对象的三种方式</font></h2><p>假如我们有一个类叫做<code>StudentClass</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentClass</span> </span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一种方式：通过类实例对象的<code>getClass</code>方获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StudentClass studentClass = <span class="keyword">new</span> StudentClass();</span><br><span class="line">Class instance = StudentClass.getClass();</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种方式：通过“类名.class”的方式取得</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class instance = StudentClass.class;</span><br></pre></td></tr></table></figure>

<ul>
<li>第三种方式：通过<code>Class</code>类的静态方法<code>forName</code>方法获得(参数是带包名的完整类名) </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Class instance = Class.forName(<span class="string">"package.StudentClass"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面三种方法取得的对象都是相同的，所以效果上等价。</p>
<h2 id="利用反射API全面分析类的信息——方法，成员变量，构造器"><a href="#利用反射API全面分析类的信息——方法，成员变量，构造器" class="headerlink" title="利用反射API全面分析类的信息——方法，成员变量，构造器"></a><font color="#8B475D">利用反射API全面分析类的信息——方法，成员变量，构造器</font></h2><p>反射的强大之处就是在获取到这个类的对象后能够知道这个类的基本组成：方法，成员变量和构造器。</p>
<p>在面向对象的语言中万物皆对象，同理在一个类中，类中的方法，构造器，成员变量也分别对应者一个对象。</p>
<p>先看<code>java</code>反射包<code>java.lang.reflect</code>下的三个类。</p>
<ol>
<li><p><code>java.lang.reflect.Method</code>对应的是保存该方法的有关信息的<code>Method</code>对象。</p>
</li>
<li><p><code>java.lang.reflect.Field</code>对应的是保存该成员变量的有关信息的<code>Filed</code>对象。</p>
</li>
<li><p><code>java.lang.reflect.Constructor</code>对应的是保存该构造器的有关信息的<code>Constructor</code>对象。</p>
</li>
</ol>
<p>假设clz是一个类的<code>class</code>对象：</p>
<ul>
<li>通过<code>clz.getDeclaredMethods()</code>可取得这个类中所有声明方法对应的<code>Method</code>对象组成的数组</li>
<li>通过 <code>clz.getDeclaredFields()</code>可取得这个类中所有声明的成员变量对应的<code>Field</code>对象组成的数组</li>
<li>通过 <code>clz.getConstructors()</code>; 可取得这个类中所有构造函数所对应的<code>Constructor</code>对象所组成的数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取方法对象列表</span></span><br><span class="line">Method [] methods = clz.getDeclaredMethods(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量对象列表</span></span><br><span class="line">Field [] fields = clz.getDeclaredFields();   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造函数对象列表</span></span><br><span class="line">Constructor [] constructors = clz.getConstructors();</span><br></pre></td></tr></table></figure>

<h5 id="getMethods和getDeclaredMethods方法"><a href="#getMethods和getDeclaredMethods方法" class="headerlink" title="getMethods和getDeclaredMethods方法"></a><code>getMethods</code>和<code>getDeclaredMethods</code>方法</h5><ul>
<li><code>getMethods</code>取得的<code>method</code>对应的方法包括从父类中继承的那一部分。</li>
<li><code>getDeclaredMethods</code>取得的<code>method</code>对应的方法不包括从父类中继承的那一部分<br>所有类的基类都是<code>Object</code>，那么如果用<code>getMethods</code>，遍历得到的结果，会发现<code>Object</code>中的基础方法名都会被打印出来。</li>
</ul>
<p>如下图：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/javaBasic/javaBasic06-1.png" alt="image"></p>
<h5 id="通过method-getReturnType-获取方法返回值对应的Class对象"><a href="#通过method-getReturnType-获取方法返回值对应的Class对象" class="headerlink" title="通过method.getReturnType()获取方法返回值对应的Class对象"></a>通过<code>method.getReturnType()</code>获取方法返回值对应的Class对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class returnClass = method.getReturnType(); <span class="comment">// 获取方法返回值对应的Class对象</span></span><br><span class="line">String returnName = returnClass.getName();  <span class="comment">//获取返回值所属类的类名——也即返回值类型</span></span><br></pre></td></tr></table></figure>

<h5 id="通过method-getParameterTypes-获取方法各参数的Class对象组成的数组"><a href="#通过method-getParameterTypes-获取方法各参数的Class对象组成的数组" class="headerlink" title="通过method.getParameterTypes()获取方法各参数的Class对象组成的数组"></a>通过<code>method.getParameterTypes()</code>获取方法各参数的Class对象组成的数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class [] paramsClasses = method.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Class pc: paramsClasses) &#123;</span><br><span class="line">    String paramStr = pc.getName(); <span class="comment">// 获取当前参数类型</span></span><br><span class="line">    paramsStr+=paramStr + <span class="string">"  "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="获取成员变量类型对应的的Class对象"><a href="#获取成员变量类型对应的的Class对象" class="headerlink" title="获取成员变量类型对应的的Class对象"></a>获取成员变量类型对应的的Class对象</h5><p>获取私有成员变量，必须修改访问权限为   <code>true</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field field = clz.getDeclaredField(<span class="string">"name"</span>);  <span class="comment">// 取得名称为name的field对象</span></span><br><span class="line">field.setAccessible(<span class="keyword">true</span>); <span class="comment">// 这一步很重要！！！设置为true才能访问私有成员变量name的值！</span></span><br><span class="line">String nameValue = (String) field.get(obj); <span class="comment">// 获取obj中name成员变量的值</span></span><br></pre></td></tr></table></figure>

<h5 id="通过getType方法读取成员变量类型的Class对象"><a href="#通过getType方法读取成员变量类型的Class对象" class="headerlink" title="通过getType方法读取成员变量类型的Class对象"></a>通过<code>getType</code>方法读取成员变量类型的Class对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field field = class1.getDeclaredField(number<span class="string">");</span></span><br><span class="line"><span class="string">System.out.print(field.getType().getName());</span></span><br></pre></td></tr></table></figure>

<h5 id="利用反射API分析类中构造器信息"><a href="#利用反射API分析类中构造器信息" class="headerlink" title="利用反射API分析类中构造器信息"></a>利用反射API分析类中构造器信息</h5><p>我们看下获取一个类实例的所有构造参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test06</span><span class="params">(String param1, <span class="keyword">int</span> param2)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void printContructorsParams (Object obj) &#123;</span><br><span class="line">Class c = obj.getClass();  // 取得obj所属类对应的Class对象</span><br><span class="line">Constructor [] constructors = c.getDeclaredConstructors();</span><br><span class="line">for (Constructor constructor : constructors) &#123;</span><br><span class="line">  Class [] paramsClasses =  constructor.getParameterTypes();</span><br><span class="line">  String paramsStr = &quot;&quot;;</span><br><span class="line">  for (Class pc : paramsClasses) &#123;</span><br><span class="line">    String paramStr = pc.getName();</span><br><span class="line">    paramsStr+=paramStr + &quot;  &quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(&quot;构造函数的所有参数的类型列表：&quot; + paramsStr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//执行结果</span><br><span class="line"></span><br><span class="line">构造函数的所有参数的类型列表：java.lang.String  int</span><br></pre></td></tr></table></figure>

<h2 id="利用反射动态加载类，并用该类创建实例对象"><a href="#利用反射动态加载类，并用该类创建实例对象" class="headerlink" title="利用反射动态加载类，并用该类创建实例对象"></a><font color="#8B475D">利用反射动态加载类，并用该类创建实例对象</font></h2><p>我们用普通的方式使用一个类的时候，类是静态加载的<br>，而使用<code>Class.forName(“XXX”)</code>这种方式，则属于动态加载一个类</p>
<p>静态加载的类在编译的时候就能确定该类是否存在，但动态加载一个类的时候却无法在编译阶段确定是否存在该类，而是在运行时候才能够确定是否有这个类，所以要捕捉可能发生的异常。</p>
<p>这也是在开发中最常用的一种动态加载方式。</p>
<p>在Class类中有一个静态方法<code>newInstance</code>可以返回一个实例对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Class.forName(<span class="string">"package.Test"</span>);</span><br><span class="line">Test test = (Test) clz.newInstance();</span><br></pre></td></tr></table></figure>

<h2 id="反射的特点"><a href="#反射的特点" class="headerlink" title="反射的特点"></a><font color="#8B475D">反射的特点</font></h2><blockquote>
<p>优点：</p>
</blockquote>
<ul>
<li>灵活、自由度高，不受类的访问权限限制，想对类做啥就做啥。</li>
</ul>
<blockquote>
<p>缺点:</p>
<ul>
<li>性能问题</li>
</ul>
</blockquote>
<p> 通过反射访问、修改类的属性和方法时会远慢于直接操作，但性能问题的严重程度取决于在程序中是如何使用反射的。如果使用得很少，不是很频繁，性能将不会是什么问题。</p>
<ul>
<li><p>安全性问题</p>
<p>反射可以随意访问和修改类的所有状态和行为，破坏了类的封装性，如果不熟悉被反射类的实现原理，随意修改可能导致潜在的逻辑问题；</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font color="#8B475D">总结</font></h2><ul>
<li>反射为我们提供了全面的分析类信息的能力，例如类的方法，成员变量和构造器等的相关信息，反射能够让我们很方便的获取这些信息， 而实现这个获取过程的关键是取得类的<code>Class</code>对象，然后根据<code>Class</code>对象取得相应的<code>Method</code>对象，<code>Field</code>对象和<code>Constructor</code>对象，再分别根据各自的API取得信息。</li>
<li>反射还为我们提供动态加载类的能力</li>
<li>API中<code>getDeclaredXXX</code>和<code>getXXX</code>的区别在于前者只获取本类声明的XXX（如成员变量或方法），而不获取超类中继承的XXX， 后者都可以获取</li>
<li>私有成员变量和私有方法是不能直接获取到值的！因为java本身的保护机制，允许你取得私有成员变量的类型，但是不允许直接获取值，所以要对对应的field对象调用file.setAccessible(true) 放开权限。</li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/16/05-补码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="96gh'home">
      <meta itemprop="description" content="闲敲棋子落灯花">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/16/05-补码/" class="post-title-link" itemprop="url">05-补码</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-16 08:45:48" itemprop="dateCreated datePublished" datetime="2019-01-16T08:45:48+08:00">2019-01-16</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">2.1k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">2 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>计算机如何来保存负数呢？其实只要达到这样的目的：正数负数都有一个唯一标识即可，但是，正如人类用+1和-1来表示可以提高效率一样，也得有一个比较适当的适合我们的计算机识别的一个方式。</p>
<h2 id="问题的由来"><a href="#问题的由来" class="headerlink" title="问题的由来"></a><font color="#8B475D">问题的由来</font></h2><p>为了方便，我们先假设一个整型数字，用最后4个bit来表示。</p>
<p>举例来说，+2在计算机是<code>0010</code>，那么-2怎么表示那？</p>
<p>我们可以让第一位来当做符号位，当他等于0时就表示正数，当为1时表示负数，那么-2就可以写为<code>1010</code>。</p>
<p>更多例子如下：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/javaBasic/javabasic5-1.png" alt="image"></p>
<p>这种方式方便了我们储存数据，因为正负数字都有了标识。但是加入我们去进行加减操作时我们发现2 + (-2) = <code>0010 + 1010 = 1100</code> ，<code>1100</code>是-4，但是我们希望它等于2。 </p>
<p>为了解决这个问题，我们来用反码来看一下。</p>
<h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a><font color="#8B475D">反码</font></h2><p>正数的反码是它本身，负数的反码是除了符号位不变，剩下的各位取反。</p>
<p><img src="http://blog-picture-g.test.upcdn.net/javaBasic/javabasic5-2.png" alt="image"></p>
<p>这样的话，我们反码的方式来试一下1和-1相加<code>0001+1110=1111</code>，但是问题又出来了，细心的同学可能会发现<code>1111</code>的反码是<code>1000</code>也就是<code>-0</code>,<code>0000</code>也是表示<code>+0</code>,但是<code>+0</code>和<code>-0</code>有区别吗<del>~</del>,好像没什么意义。</p>
<p>这时候我们来试一下补码。</p>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a><font color="#8B475D">补码</font></h2><p>补码就是在反码的基础上加1。</p>
<p><img src="http://blog-picture-g.test.upcdn.net/javaBasic/javabasic5-3.png" alt="image"></p>
<p>我们还用上面的来计算1和-1的补码相加   </p>
<p><code>0001</code> + <code>1111</code>会溢出一位，因为我们上面假设只有4个bit，所以溢出的部分直接丢弃了，所以位<code>0000</code>,所以上面正负零的问题也解决了。</p>
<h2 id="补码怎么求"><a href="#补码怎么求" class="headerlink" title="补码怎么求"></a><font color="#8B475D">补码怎么求</font></h2><p>上面已经说的很详细啦，比如-4，就是在4(0100)的基础上取反(1011)再加一(1100).</p>
<p>上面也解释了为什么要用补码。即保证了对称的正负数相加为0并且0只有一种表示方式。</p>
<p>还有一个重要的点就是，我们注意到，7-4其实我们都是转换成7+(-4)，也就是说，在计算机中，减法都是用加法的逻辑实现的。</p>
<p>即：一套加法的电路实现加减法。此外，乘法和除法其实都是加法这套电路实现的。</p>
<h2 id="补码的本质"><a href="#补码的本质" class="headerlink" title="补码的本质"></a><font color="#8B475D">补码的本质</font></h2><p>在实现减法逻辑时，计算机内部同样是使用被减数的补码通过加法的逻辑来实现的。</p>
<p>这里假设存储一个整型用8个bit。  </p>
<p>要将正数转成对应的负数，其实只要用0减去这个数就可以了。比如，-8其实就是0-8。</p>
<p>则8的二进制是00001000，-8就可以用下面的式子求出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">　００００００００</span><br><span class="line">　</span><br><span class="line">－００００１０００</span><br><span class="line"></span><br><span class="line">－－－－－－－－－</span><br></pre></td></tr></table></figure>

<p>因为00000000（被减数）小于0000100（减数），所以不够减。请回忆一下小学算术，如果被减数的某一位小于减数，我们怎么办？很简单，问上一位借1就可以了。</p>
<p>所以，0000000也问上一位借了1，也就是说，被减数其实是100000000，算式也就改写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">１００００００００</span><br><span class="line"></span><br><span class="line">－００００１０００</span><br><span class="line"></span><br><span class="line">－－－－－－－－－</span><br><span class="line"></span><br><span class="line">　１１１１１０００</span><br></pre></td></tr></table></figure>

<p>进一步观察，可以发现100000000 = 11111111 + 1，所以上面的式子可以拆成两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　１１１１１１１１</span><br><span class="line">　</span><br><span class="line">－００００１０００</span><br><span class="line"></span><br><span class="line">－－－－－－－－－</span><br><span class="line"></span><br><span class="line">　１１１１０１１１</span><br><span class="line">　</span><br><span class="line">＋０００００００１</span><br><span class="line"></span><br><span class="line">－－－－－－－－－</span><br><span class="line"></span><br><span class="line">　１１１１１０００</span><br></pre></td></tr></table></figure>

<p>通过这一步，我们就从数学上知道了为什么补码是取反加一了。</p>
<p>你看，求任何一个负数，都是0-正数，那么就用借位的思想来，则变成100000000。</p>
<p>100000000则可以分解为11111111+00000001。</p>
<p>此时求负数的过程就就变成11111111-X+1</p>
<ul>
<li>而先用11111111来减这个正数，这个结果就是对正数取反。</li>
<li>此时再加上另外一个1.</li>
</ul>
<p>这与我们求补码的过程是一样的，这也解释了为什么要这样求补码。</p>
<p>将上面的特例抽象一下，用统一表达式来证明一下。</p>
<p>我们要证明的是，X-Y或X+(-Y)可以用X加上Y的补码完成。</p>
<p>Y的补码等于(11111111-Y)+1。所以，X加上Y补码，就等于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X + (<span class="number">11111111</span>-Y) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>我们假定这个算式的结果等于Z，即</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z = X + (<span class="number">11111111</span>-Y) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>接下来，分成两种情况讨论。</p>
<ul>
<li><p>第一种情况，如果X小于Y，那么Z是一个负数。</p>
<p>由Y的补码等于(11111111-Y)+1，标记为F=(11111111-Y)+1,那么如何根据F逆向求Y呢？</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y=<span class="number">1111111</span>-(F-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>OK,因为此时Z是一个负数，那么Z进行补码的逆运算就可以求出它的绝对值，即正数。再加一个符号，两者相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z = -[<span class="number">11111111</span>-(Z-<span class="number">1</span>)] = -[<span class="number">11111111</span>-(X + (<span class="number">11111111</span>-Y) + <span class="number">1</span>-<span class="number">1</span>)] = X - Y</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种情况，如果X大于Y</li>
</ul>
<p>这意味着Z肯定大于11111111，但是我们规定了这是8位机，最高的第9位是溢出位，必须被舍去，这相当于减去100000000。所以，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z = Z - <span class="number">100000000</span> = X + (<span class="number">11111111</span>-Y) + <span class="number">1</span> - <span class="number">100000000</span> = X - Y</span><br></pre></td></tr></table></figure>

<p>这就证明了，在正常的加法规则下，可以利用2的补码得到正数与负数相加的正确结果。换言之，计算机只要部署加法电路和补码电路，就可以完成所有整数的加法。    </p>
<p>部分整理自：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2009/08/twos_complement.html" target="_blank" rel="noopener">关于2的补码</a></li>
</ul>
<ul>
<li><a href="https://www.zhihu.com/question/20159860" target="_blank" rel="noopener">知乎评论</a></li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/14/04-理解类、对象、面向对象编程、面向接口编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="96gh'home">
      <meta itemprop="description" content="闲敲棋子落灯花">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/14/04-理解类、对象、面向对象编程、面向接口编程/" class="post-title-link" itemprop="url">04-理解类、对象、面向对象编程、面向接口编程</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-14 11:11:48" itemprop="dateCreated datePublished" datetime="2019-01-14T11:11:48+08:00">2019-01-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">3.4k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">3 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>什么是类和对象，有人说类是对象的抽象，对象是类的实例，下面我们来好好理解下，类和对象和面向对象编程，面向接口编程。</p>
<h2 id="类和对象的概念"><a href="#类和对象的概念" class="headerlink" title="类和对象的概念"></a><font color="#8B475D">类和对象的概念</font></h2><p>首先总结一下：类是一个模板，对象就是用这个模板创造出来的东西。也就是上面说的类是对象的抽象，对象是类的实例。</p>
<p>比如，男孩，他就是一个模板，男的就行，那么对象是什么呢？就是具体某个男孩，比如男孩<code>BOB</code>，男孩<code>fourColor</code>.</p>
<p>请看下面一张图：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/javaBasic/javabasic4-1.png" alt="image"></p>
<p>男孩女孩是比较抽象的概念，是模板，左边一排就是其具体的一些对象。你看长的都不一样，有的黑，有的白，有的高，有的矮，国家地区也不一样。但是他们都属于男孩或者女孩。</p>
<p>那么同理，人就是一个类，男孩女孩就是人的子类，因为人可能不仅包括男孩女孩，还包括第三性别这个类。</p>
<p>这里还引出了JAVA特性中的继承。继承简单理解就是父类有的东西(访问级别不能是private)的，那都是你的。比如你老爸的房子，就是属于你的，你出入自由。</p>
<p>人还可以分为胖人和瘦人这个子类。所以只要是抽象的模板，就是一个类。</p>
<ul>
<li>对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>
<li>类：类是一个模板，它描述一类对象的行为和状态。</li>
</ul>
<h2 id="Java中创建类"><a href="#Java中创建类" class="headerlink" title="Java中创建类"></a><font color="#8B475D">Java中创建类</font></h2><h5 id="构造器方法说明"><a href="#构造器方法说明" class="headerlink" title="构造器方法说明"></a>构造器方法说明</h5><p>需要创造一个类对象出来的时候，要用到这个类的构造器方法，那么啥是构造器方法呢？构造器方法就是创造类时的初始化方法，和类同名的方法，你可以在里面写自己的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名称 </span>&#123;</span><br><span class="line">    访问权限 构造方法名称()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">   <span class="comment">//构造方法一</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"nothing to do..."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//构造方法二</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="comment">//这里就可以给每条new出来的对象(狗)初始化一个名字</span></span><br><span class="line">      System.out.println(<span class="string">"hi,my name is "</span>+name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="一个相对比较完整的类"><a href="#一个相对比较完整的类" class="headerlink" title="一个相对比较完整的类"></a>一个相对比较完整的类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名称 </span>&#123;</span><br><span class="line">    <span class="comment">//构造器方法</span></span><br><span class="line">    <span class="comment">//声明成员变量---这个变量属于这个类</span></span><br><span class="line">    <span class="comment">//声明成员方法</span></span><br><span class="line">        <span class="comment">//在方法里面定义的变量是局部变量，区别于成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造方法一</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"nothing to do..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造方法二</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">       <span class="comment">//这里就可以给每条new出来的对象(狗)初始化一个名字</span></span><br><span class="line">       System.out.println(<span class="string">"hi,my name is "</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//狗的颜色--成员属性</span></span><br><span class="line">    <span class="keyword">public</span> String color;<span class="comment">//一般是private，赋值用set方法，取值用get方法，这里只是演示</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//狗的行为，它会叫---成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//局部变量</span></span><br><span class="line">        System.out.println(<span class="string">"我会叫：汪汪汪~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a><font color="#8B475D">创建对象</font></h2><p>语法：</p>
<blockquote>
<p> 类名 对象名 = new 类名() ;</p>
</blockquote>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog fourcolor ;    <span class="comment">// 先声明一个 Dog 类的对象 fourcolor</span></span><br><span class="line">fourcolor = <span class="keyword">new</span> Dog(<span class="string">"fourcolor"</span>) ;  <span class="comment">// 用 new 关键字实例化 Dog 的对象 fourcolor,此时调用构造方法二</span></span><br></pre></td></tr></table></figure>

<p>通过<code>Dog</code>这个类可以创造<code>fourcolor</code>对象.下面我才能操作这个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让它的颜色为黑色</span></span><br><span class="line">fourcolor.color = <span class="string">"black"</span>;</span><br><span class="line"><span class="comment">//让它叫</span></span><br><span class="line">fourcolor.say();</span><br></pre></td></tr></table></figure>

<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a><font color="#8B475D">面向对象</font></h2><p>在理解了什么是类，什么是对象，就可以来说说面向对象到底是什么了。</p>
<p>先来说说面向过程，大家都学习过C语言。C语言就是典型的面向过程的语言。</p>
<p>举个例子：要把大象装进冰箱里，这件事，面向过程的程序员是这样思考的：</p>
<ul>
<li>把冰箱门儿打开。</li>
<li>把大象装进去。</li>
<li>把冰箱门儿关上。</li>
</ul>
<p>上面的每一件事都用一个函数来实现。抽象为下面三个函数：</p>
<ul>
<li>openTheDoor()；</li>
<li>pushElephant()；</li>
<li>closeTheDoor()；</li>
</ul>
<p>这样不挺好的吗？为什么不用面向过程的这种思维来编程呢，还要搞出什么面向对象来。</p>
<p>需求又来啦：</p>
<ul>
<li>「我要把大象装微波炉里」</li>
<li>「我要把狮子也装冰箱里」</li>
<li>「我要把大象装冰箱，但是门别关，敞着就行」<br>这个时候，面向过程的程序员就悲剧了，来一个需求我就写一个函数，我还能下班吗？</li>
</ul>
<p>面向对象从另一个角度来解决这个问题。它抛弃了函数，把「对象」作为程序的基本单元。</p>
<p>面向对象的世界里，到处都是对象。即：万物皆对象。</p>
<p>比如人这个类，每个具体的人(对象)都要有这样的属性：身高、体重、年龄。每个人都有这样的行为：吃饭、睡觉、上厕所。</p>
<p>那么，这些通用的属性+方法可以构建一个模板：人这个类。因为每个具体的人（对象）都需要这些基本的东西。当然了，每个人具体什么身高、什么体重、吃什么都是不一样的，所以每个对象一般都是不一样的。但是模板是一样的。</p>
<p>那么，回到刚才的需求，面向对象是如何思考这件事的呢？</p>
<ul>
<li>向冰箱下达「开门」的命令。</li>
<li>向大象下达「进冰箱」的命令。</li>
<li>向冰箱下达「关门」的命令。</li>
</ul>
<p>就是说，我不用亲自管开门的细节，我只要叫他开门即可。</p>
<blockquote>
<p>我们创建的对象，应该是刚刚好能做完它能做的事情，不多做，不少做。多做了容易耦合，各种功能杂糅在一个对象里。比如我有一个对象叫「汽车」，可以「行驶」，可以「载人」，现在的需求是要实现「载人飞行」，就不能重用这个对象，必须新定义一个对象「飞机」来做。如果你给「汽车」插上了翅膀，赋予了它「飞行」的能力，那么新来的同学面对你的代码就会莫名其妙，无从下手。</p>
</blockquote>
<p>但是不禁要问：怎么实现这种下达命令就可以自动去执行的效果呢？或者说，我怎么知道它有这个功能啊！</p>
<h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a><font color="#8B475D">面向接口编程</font></h2><p>现在我们把「数据」和「行为」都封装到了对象里，相当于对象成了一个黑匣子，那我们怎么知道对象具有什么样的能力呢？这个问题的关键就是接口。</p>
<p>因为无论是把大象装进洗衣机还是冰箱，都要求洗衣机或者冰箱有开门和关门的功能。这个时候，我们就可以抽象出来一个接口：【自动门】。这个接口里面定义两个能力：【开门】和【关门】。</p>
<p>让洗衣机、冰箱、微波炉这些带门的东西全部实现【自动门】接口。</p>
<p>这个时候，每个具体的实现可能略有不同，比如冰箱开门是往外拽，但是洗衣机开门可能是往上翻盖子。</p>
<p>此时，我有一个需求，把大象放进冰箱。我一看，冰箱实现了【自动门】这个接口，里面有【开门】和【关门】两个方法，ok，我知道冰箱是可以开门和关门了，那就好办了。我直接下达命令即可。还是跟上面一样的步骤.</p>
<ul>
<li>向冰箱下达「开门」的命令。</li>
<li>向大象下达「进冰箱」的命令。</li>
<li>向冰箱下达「关门」的命令。</li>
</ul>
<p>此时，需要将狮子也装冰箱里。那还是一样：</p>
<ul>
<li>向冰箱下达「开门」的命令。</li>
<li>向狮子下达「进冰箱」的命令。</li>
<li>向冰箱下达「关门」的命令。</li>
</ul>
<p>此时，我要把大象装冰箱，但是门别关，敞着就行，那就：</p>
<ul>
<li>向冰箱下达「开门」的命令。</li>
<li>向大象下达「进冰箱」的命令。</li>
</ul>
<p>是不是很方便？冰箱也可以换，我可以换成任何东西，只要实现了这个接口，这些东西就都有这些能力，那我才不管里面到底怎么实现的呢，直接下达【开门】【关门】命令即可。</p>
<p>这也引入了JAVA特性中另一个特性：封装。外界不知道里面实现细节，只需要知道它的功能和入参即可。</p>
<p>这就是面向过程和面向对象编程的区别，也顺带地理解了什么是面向接口编程。这是学习JAVA最基础也是最核心的点。</p>
<p>整理自：</p>
<ul>
<li><a href="https://tryenough.com/java05" target="_blank" rel="noopener">https://tryenough.com/java05</a></li>
<li><a href="http://www.woshipm.com/pmd/294180.html" target="_blank" rel="noopener">http://www.woshipm.com/pmd/294180.html</a></li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/12/03-字符串动态创建过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="96gh'home">
      <meta itemprop="description" content="闲敲棋子落灯花">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/12/03-字符串动态创建过程/" class="post-title-link" itemprop="url">03-字符串动态创建过程</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-12 14:21:48" itemprop="dateCreated datePublished" datetime="2019-01-12T14:21:48+08:00">2019-01-12</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">4.6k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">4 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇我们讨论了字符串的不可变性，这篇我们来看下字符串对象的创建和动态加入常量池的分析。</p>
<p>有两个面试题：</p>
<p>Q1：<code>String s = new String("hollis");</code>定义了几个对象。</p>
<p>Q2：如何理解<code>String</code>的<code>intern</code>方法？</p>
<p>A1：对于通过 <code>new</code> 产生的对象，会先去常量池检查有没有 <code>abc</code>，如果没有，先在常量池创建一个 <code>abc</code> 对象，然后在堆中创建一个常量池中此 <code>abc</code> 对象的拷贝对象。所以答案是：一个或两个。如果常量池中原来没有<code>abc</code> 就是两个。如果原来的常量池中存在<code>abc</code>时，就是一个。</p>
<p>A2：当一个<code>String</code>实例调用<code>intern()</code>方法时，JVM会查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于<code>str</code>的字符串并返回它的引用；</p>
<h2 id="字面量和运行时常量池"><a href="#字面量和运行时常量池" class="headerlink" title="字面量和运行时常量池"></a><font color="#8B475D">字面量和运行时常量池</font></h2><p>JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串常量池。</p>
<p>在JVM运行时区域的方法区中，有一块区域是运行时常量池，主要用来存储编译期生成的各种字面量和符号引用。</p>
<p>了解过JVM就会知道，在java代码被javac编译之后，文件结构中是包含一部分<code>Constant pool</code>的。比如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过编译后，常量池内容如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">  #1 = Methodref          #4.#20         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">  #2 = String             #21            // abc</span><br><span class="line">  #3 = Class              #22            // StringDemo</span><br><span class="line">  #4 = Class              #23            // java/lang/Object</span><br><span class="line">  ...</span><br><span class="line">  #16 = Utf8               s</span><br><span class="line">  ..</span><br><span class="line">  #21 = Utf8               abc</span><br><span class="line">  #22 = Utf8               StringDemo</span><br><span class="line">  #23 = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure>

<p>上面的Class文件中的常量池中，比较重要的几个内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#16 = Utf8               s</span><br><span class="line">#21 = Utf8               abc</span><br><span class="line">#22 = Utf8               StringDemo</span><br></pre></td></tr></table></figure>

<p>上面几个常量中，<code>s</code>就是前面提到的符号引用，而<code>abc</code>就是前面提到的字面量。而Class文件中的常量池部分的内容，会在运行期被运行时常量池加载进去。</p>
<h2 id="new-String创建了几个对象"><a href="#new-String创建了几个对象" class="headerlink" title="new String创建了几个对象"></a><font color="#8B475D">new String创建了几个对象</font></h2><p>下面，我们可以来分析下<code>String s = new String("abc");</code>创建对象情况了。</p>
<p>这段代码中，我们可以知道的是，在编译期，符号引用<code>s</code>和字面量<code>abc</code>会被加入到Class文件的常量池中。由于是new的方式，在类加载期间，先去常量池检查有没有 <code>abc</code>，如果没有，先在常量池创建一个 <code>abc</code> 对象。</p>
<p>在运行期间，在堆中创建一个常量池中此 <code>abc</code> 对象的拷贝对象。</p>
<h2 id="运行时常量池的动态扩展"><a href="#运行时常量池的动态扩展" class="headerlink" title="运行时常量池的动态扩展"></a><font color="#8B475D">运行时常量池的动态扩展</font></h2><p>编译期生成的各种字面量和符号引用是运行时常量池中比较重要的一部分来源，但是并不是全部。那么还有一种情况，可以在运行期像运行时常量池中增加常量。那就是<code>String</code>的<code>intern</code>方法。</p>
<p>当一个<code>String</code>实例调用<code>intern</code>方法时，JVM会查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于<code>str</code>的字符串并返回它的引用；</p>
<p><code>intern()</code>有两个作用，第一个是将字符串字面量放入常量池（如果池没有的话），第二个是返回这个常量的引用。</p>
<p>我们来看一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        String s1 = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"s1==s2:"</span>+(s1==s2));</span><br><span class="line"></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"hello world"</span>).intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"s1==s3:"</span>+(s1==s3));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">s1==s2:<span class="keyword">false</span></span><br><span class="line">s1==s3:<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>我们可以简单的理解为<code>String s1 = "hello world";</code>和<code>String s3  = new String("hello world").intern();</code>做的事情是一样的（但实际有些区别，这里暂不展开）。都是定义一个字符串对象，然后将其字符串字面量保存在常量池中，并把这个字面量的引用返回给定义好的对象引用。</p>
<p>对于<code>String s3 = new String("hello world").intern();</code>，在不调<code>intern</code>情况，<code>s3</code>指向的是JVM在堆中创建的那个对象的引用的（如<code>s2</code>）。但是当执行了<code>intern</code>方法时，<code>s3</code>将指向字符串常量池中的那个字符串常量。</p>
<p>由于<code>s1</code>和<code>s3</code>都是字符串常量池中的字面量的引用，所以<code>s1==s3</code>。但是，<code>s2</code>的引用是堆中的对象，所以<code>s2!=s1</code>。</p>
<h2 id="intern的正确用法"><a href="#intern的正确用法" class="headerlink" title="intern的正确用法"></a><font color="#8B475D">intern的正确用法</font></h2><p>不知道，你有没有发现，在<code>String s3 = new String("abc").intern();</code>中，其实<code>intern</code>是多余的？</p>
<p>因为就算不用<code>intern</code>，<code>abc</code>作为一个字面量也会被加载到Class文件的常量池””，进而加入到运行时常量池中，为啥还要多此一举呢？到底什么场景下才会用到<code>intern</code>呢?<br>在解释这个之前，我们先来看下以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = s1 + s2;</span><br><span class="line">String s4 = <span class="string">"hello"</span> + <span class="string">"world"</span>;</span><br></pre></td></tr></table></figure>

<p>在经过反编译后，得到代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = (<span class="keyword">new</span> StringBuilder()).append(s1).append(s2).toString();</span><br><span class="line">String s4 = <span class="string">"helloworld"</span>;</span><br></pre></td></tr></table></figure>

<p>这就是循环拼接字符串不准使用”+”而必须使用<code>StringBuilder</code>，因为反编译出的字节码文件显示每次循环都会 <code>new</code> 出一个<code> StringBuilder</code> 对象，然后进行<code>append</code> 操作，最后通过 <code>toString</code> 方法返回 <code>String</code> 对象，造成内存资源浪费。</p>
<p>不恰当的方式形如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"start"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    str = str + <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，言归正传，可以发现，同样是字符串拼接，<code>s3</code>和<code>s4</code>在经过编译器编译后的实现方式并不一样。<code>s3</code>被转化成<code>StringBuilder</code>及<code>append</code>，而<code>s4</code>被直接拼接成新的字符串。</p>
<p>如果你感兴趣，你还能发现，<code>String s4 = s1 + s2;</code> 经过编译之后，常量池中是有两个字符串常量的分别是 <code>hello</code>、<code>world</code>（其实<code>hello</code>和 <code>world</code>是<code>String s1 = "hello";</code>和<code>String s2 = "world";</code>定义出来的），拼接结果<code>helloworld</code>并不在常量池中。</p>
<p>如果代码只有<code>String s4 = "hello" + "world";</code>，那么常量池中将只有<code>helloworld</code>而没有<code>hello</code>和 <code>world</code>。</p>
<p><strong>究其原因，是因为常量池要保存的是已确定的字面量值。也就是说，对于字符串的拼接，纯字面量和字面量的拼接，会把拼接结果作为常量保存到字符串。</strong></p>
<p>如果在字符串拼接中，有一个参数是非字面量，而是一个变量的话，整个拼接操作会被编译成StringBuilder.append，这种情况编译器是无法知道其确定值的。只有在运行期才能确定。</p>
<p>那么，有了这个特性了，<code>intern</code>就有用武之地了。<strong>那就是很多时候，我们在程序中用到的字符串是只有在运行期才能确定的，在编译期是无法确定的，那么也就没办法在编译期被加入到常量池中。</strong></p>
<p>这时候，对于那种可能经常使用的字符串，使用<code>intern</code>进行定义，每次JVM运行到这段代码的时候，就会直接把常量池中该字面值的引用返回，这样就可以减少大量字符串对象的创建了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font color="#8B475D">总结</font></h2><h5 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span>; </span><br><span class="line">System.out.println(str1 == <span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>栈中开辟一块空间存放引用str1；</li>
<li>String池中开辟一块空间，存放String常量”abc”；</li>
<li>引用str1指向池中String常量”abc”；</li>
<li>str1所指代的地址即常量”abc”所在地址，输出为true</li>
</ul>
<h5 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); </span><br><span class="line">System.out.println(str2 == <span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>栈中开辟一块空间存放引用str2；</li>
<li>堆中开辟一块空间存放一个新建的String对象”abc”；</li>
<li>引用str2指向堆中的新建的String对象”abc”；</li>
<li>str2所指代的对象地址为堆中地址，而常量”abc”地址在池中，输出为false；</li>
</ul>
<h5 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (3)</span></span><br><span class="line">String str1 = <span class="string">"a"</span>；</span><br><span class="line">String str2 = <span class="string">"b"</span>；</span><br><span class="line">String str3 = str1 + <span class="string">"b"</span>；</span><br><span class="line"><span class="comment">//str1 和 str2 是字符串常量，所以在编译期就确定了。</span></span><br><span class="line"><span class="comment">//str3 中有个 str1 是引用，所以不会在编译期确定。</span></span><br><span class="line"><span class="comment">//又因为String是 final 类型的，所以在 str1 + "b" 的时候实际上是创建了一个新的对象，在把新对象的引用传给str3。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）</span></span><br><span class="line"><span class="keyword">final</span> String str1 = <span class="string">"a"</span>；</span><br><span class="line">String str2 = <span class="string">"b"</span>；</span><br><span class="line">String str3 = str1 + <span class="string">"b"</span>；</span><br><span class="line"><span class="comment">//这里和(3)的不同就是给 str1 加上了一个final，这样str1就变成了一个常量。</span></span><br><span class="line"><span class="comment">//这样 str3 就可以在编译期中就确定了</span></span><br></pre></td></tr></table></figure>


<h5 id="第四种情况"><a href="#第四种情况" class="headerlink" title="第四种情况"></a>第四种情况</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"ab"</span>；</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"ab"</span>);</span><br><span class="line">System.out.println(str1== str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2.intern() == str1);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>原理和上面一样</p>
<p>整理自：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI4OTA3NDQ0Nw==&mid=2455545837&idx=1&sn=5dde0e68c22e1827cc7422d1af39a2de&chksm=fb9cbb8dcceb329b88dc91fe4c6a9d6535752cdd1191092d93da665b051f16c06bc9e0e2e508&mpshare=1&scene=24&srcid=0121duABpN7IHaUl1JxPtp66&ascene=14&devicetype=android-26&version=2700003b&nettype=WIFI&abtest_cookie=BgABAAgACgALABIAEwAUAAcAnoYeACaXHgBXmR4Am5keAJ2ZHgC3mR4A0pkeAAAA&lang=zh_CN&pass_ticket=UZ59UG%2Bqu2i5egH9vmxuu5prus%2FoCSM%2B4QOgzET8cSVcTyIG%2BDpQQbT5Prwgm96v&wx_header=1" target="_blank" rel="noopener">我终于搞清楚了和String有关的那点事儿。</a></li>
<li><a href="https://www.jianshu.com/p/2624036c9daa" target="_blank" rel="noopener">https://www.jianshu.com/p/2624036c9daa</a></li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/02-字符串不可变性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="96gh'home">
      <meta itemprop="description" content="闲敲棋子落灯花">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/10/02-字符串不可变性/" class="post-title-link" itemprop="url">02-字符串不可变性</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-10 18:20:48" itemprop="dateCreated datePublished" datetime="2019-01-10T18:20:48+08:00">2019-01-10</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">4.8k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">4 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在java字符串中，最显著的特点就是字符串的不可变性。本文来理解下字符串的这个特性。</p>
<h2 id="什么是不可变对象"><a href="#什么是不可变对象" class="headerlink" title="什么是不可变对象"></a><font color="#8B475D">什么是不可变对象</font></h2><p>众所周知， 在Java中， String类是不可变的。那么到底什么是不可变的对象呢？ 可以这样认为：如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p>
<h2 id="区分对象和对象的引用"><a href="#区分对象和对象的引用" class="headerlink" title="区分对象和对象的引用"></a><font color="#8B475D">区分对象和对象的引用</font></h2><p><strong>对象的引用：</strong><br>当初我在初学C语言时，对指针非常的迷惑，首先指针的定义是利用地址，它的值直接指向存在内存中另一个地方的值，我们大概能理解他的意思，就是我们定义这个指针是指向另外一个内存地址。我们可以和java进行下比较，我们每初始化一个对象，当我们初始化这个对象后，在堆中产生了这个对象的实例，我们如何操纵这个对象的属性和方法那，首先需要在堆中找到这个对象的地址，这个能找到堆中对象地址的东西就是对象的引用，找到这个对象的地址后，我们就可以操作这个对象具体属性了。</p>
<p>对于Java初学者， 对于String是不可变对象总是存有疑惑。看下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"ABCabc"</span>;  </span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);  </span><br><span class="line">  </span><br><span class="line">s = <span class="string">"123456"</span>;  </span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">s = ABCabc</span><br><span class="line">s = <span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>有的小伙伴可能会疑惑了，String对象不是不可变的吗，为什么两次打印都不行同，是因为我们改变的是<code>s</code>的引用，就像指针一样，在字符串常量池中<code>ABCabc</code>和<code>123456</code>都没有改变，他们在内存中始终占有位置，只是我们让<code>s</code>先指向了<code>ABCabc</code>然后又让他指向了<code>123456</code>。</p>
<p>对象在内存中是一块内存区，成员变量越多，这块内存区占的空间越大。</p>
<p>引用只是一个4字节的数据，里面存放了它所指向的对象的地址，通过这个地址可以访问对象。</p>
<p>也就是说，<code>s</code> 只是一个引用，它指向了一个具体的对象，当 s=“123456”; 这句代码执行过之后，又创建了一个新的对象“123456”， 而引用s重新指向了这个新的对象，原来的对象“ABCabc”还在内存中存在，并没有改变。内存结构如下图所示：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/javaBasic/javaBasic2-1.png" alt="image"></p>
<h2 id="为什么String对象是不可变的？"><a href="#为什么String对象是不可变的？" class="headerlink" title="为什么String对象是不可变的？"></a><font color="#8B475D">为什么String对象是不可变的？</font></h2><p>要理解 String 的不可变性，首先看一下 String 类中都有哪些成员变量。 在JDK1.6中，String 的成员变量有以下几个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>  </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure>

<p>在JDK1.7和1.8中，String 类做了一些改动，主要是改变了<code>substring</code>方法执行时的行为，这和本文的主题不相关。JDK1.7中 String 类的主要成员变量就剩下了两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>  </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure>

<p>由以上的代码可以看出， 在Java中 String 类其实就是对字符数组的封装。</p>
<p>JDK6中，<code>value</code>是<code>String</code>封装的数组，<code>offset</code>是<code>String</code>在这个<code>value</code>数组中的起始位置，<code>count</code>是<code>String</code>所占的字符的个数。</p>
<p>除此之外还有一个<code>>hash</code>成员变量，是该 String 对象的哈希值的缓存，这个成员变量也和本文的讨论无关。在Java中，数组也是对象。</p>
<p>所以<code>>value</code>也只是一个引用，它指向一个真正的数组对象。其实执行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = “ABCabc<span class="string">";</span></span><br></pre></td></tr></table></figure>

<p>这句代码之后，真正的内存布局应该是这样的：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/javaBasic/javaBasic2-2.png" alt="image"></p>
<p><code>value</code>，<code>offset</code>和<code>count</code>这三个变量都是<code>private</code>的，并且没有提供<code>setValue</code>， <code>setOffset</code>和<code>setCount</code>等公共方法来修改这些值，所以在String类的外部无法修改String。也就是说一旦初始化就不能修改， 并且在String类的外部不能访问这三个成员。</p>
<p>此外，<code>value</code>，<code>offset</code>和<code>count</code>这三个变量都是<code>final</code>的， 也就是说在 String 类内部，一旦这三个值初始化了， 也不能被改变。所以可以认为 String 对象是不可变的了。</p>
<p>那么在 String 中，明明存在一些方法，调用他们可以得到改变后的值。这些方法包括<code>substring</code>， <code>replace</code>， <code>replaceAll</code>， <code>toLowerCase</code>等。例如如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"ABCabc"</span>;  </span><br><span class="line">System.out.println(<span class="string">"a = "</span> + a);  <span class="comment">//ABCabc</span></span><br><span class="line">a = a.replace(<span class="string">'A'</span>, <span class="string">'a'</span>);  </span><br><span class="line">System.out.println(<span class="string">"a = "</span> + a);  <span class="comment">//aBCabc</span></span><br></pre></td></tr></table></figure>

<p>那么<code>a</code>的值看似改变了，其实也是同样的误区。再次说明， <code>a</code>只是一个引用， 不是真正的字符串对象，在调用<code>a.replace('A', 'a')</code>时， 方法内部创建了一个新的String对象，并把这个心的对象重新赋给了引用<code>a</code>。String中<code>replace</code>方法的源码可以说明问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = value.length;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val[i] == oldChar) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                buf[j] = val[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = val[i];</span><br><span class="line">                buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);<span class="comment">//new出了新的String对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String对象真的不可变吗？"><a href="#String对象真的不可变吗？" class="headerlink" title="String对象真的不可变吗？"></a><font color="#8B475D">String对象真的不可变吗？</font></h2><p>从上文可知String的成员变量是<code>private final</code> 的，也就是初始化之后不可改变。那么在这几个成员中， <code>value</code>比较特殊，因为他是一个引用变量，而不是真正的对象。</p>
<p><code>value</code>是<code>final</code>修饰的，也就是说<code>final</code>不能再指向其他数组对象，那么我能改变<code>value</code>指向的数组吗？</p>
<p>比如将数组中的某个位置上的字符变为下划线“_”。 至少在我们自己写的普通代码中不能够做到，因为我们根本不能够访问到这个<code>value</code>引用，更不能通过这个引用去修改数组。</p>
<p>那么用什么方式可以访问私有成员呢？</p>
<p>没错，用反射，可以反射出String对象中的<code>value</code>属性， 进而改变通过获得的<code>value</code>引用改变数组的结构。下面是实例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReflection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//创建字符串"Hello World"， 并赋给引用s  </span></span><br><span class="line">    String s = <span class="string">"Hello World"</span>;   </span><br><span class="line">      </span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s); <span class="comment">//Hello World  </span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//获取String类中的value字段  </span></span><br><span class="line">    Field valueFieldOfString = String.class.getDeclaredField(<span class="string">"value"</span>);  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//改变value属性的访问权限  </span></span><br><span class="line">    valueFieldOfString.setAccessible(<span class="keyword">true</span>);  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//获取s对象上的value属性的值  </span></span><br><span class="line">    <span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//改变value所引用的数组中的第5个字符  </span></span><br><span class="line">    value[<span class="number">5</span>] = <span class="string">'_'</span>;  </span><br><span class="line">      </span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s);  <span class="comment">//Hello_World  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个过程中，<code>s</code>始终引用的同一个 String 对象，但是再反射前后，这个 String 对象发生了变化(反射的强大之处)， 也就是说，通过反射是可以修改所谓的“不可变”对象的。但是一般我们不这么做。</p>
<p>这个反射的实例还可以说明一个问题：<strong>如果一个对象，他组合的其他对象的状态是可以改变的，那么这个对象很可能不是不可变对象。例如一个Car对象，它组合了一个Wheel对象，虽然这个Wheel对象声明成了private final 的，但是这个Wheel对象内部的状态可以改变， 那么就不能很好的保证Car对象不可变。</strong></p>
<p>部分整理自：</p>
<ul>
<li><a href="https://blog.csdn.net/zhangjg_blog/article/details/18319521" target="_blank" rel="noopener">https://blog.csdn.net/zhangjg_blog/article/details/18319521</a> </li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/07/01-Integer的装箱与拆箱/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="96gh'home">
      <meta itemprop="description" content="闲敲棋子落灯花">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/07/01-Integer的装箱与拆箱/" class="post-title-link" itemprop="url">01-Integer的装箱与拆箱</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-07 15:10:48" itemprop="dateCreated datePublished" datetime="2019-01-07T15:10:48+08:00">2019-01-07</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">3.9k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">4 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在我们程序中，我们知道基本数据类型是存放在栈里面的，对象则存放在堆中，但是一般在程序中我们可以直接把<code>Integer</code>类型和<code>Int</code>类型直接进行加减操作，说明在我们程序运行的时候JDK的内部帮我们做了文章。</p>
<h2 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a><font color="#8B475D">装箱与拆箱</font></h2><p>先用<code>int</code>和<code>Integer</code><br>为例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*第一组*/</span></span><br><span class="line">        Integer num1 = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">        Integer num2 = <span class="number">128</span>;</span><br><span class="line">        System.out.println(<span class="string">"num1 == num2 : "</span> + (num1 == num2));</span><br><span class="line"></span><br><span class="line">        Integer num3 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">        Integer num4 = <span class="number">127</span>;</span><br><span class="line">        System.out.println(<span class="string">"num3 == num4 : "</span> +(num3 == num4));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*第二组*/</span></span><br><span class="line">        Integer num5 = <span class="number">128</span>;</span><br><span class="line">        Integer num6 = <span class="number">128</span>;</span><br><span class="line">        System.out.println(<span class="string">"num5 == num6 : "</span> +(num5 == num6));</span><br><span class="line"></span><br><span class="line">        Integer num7 = <span class="number">127</span>;</span><br><span class="line">        Integer num8 = <span class="number">127</span>;</span><br><span class="line">        System.out.println(<span class="string">"num7 == num8 : "</span> +(num7 == num8));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*第三组*/</span></span><br><span class="line">        Integer num9 = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">        <span class="keyword">int</span> num10 = <span class="number">128</span>;</span><br><span class="line">        System.out.println(<span class="string">"num9 == num10 : "</span> +(num9 == num10));</span><br><span class="line"></span><br><span class="line">        Integer num11 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">        <span class="keyword">int</span> num12 = <span class="number">127</span>;</span><br><span class="line">        System.out.println(<span class="string">"num11 == num12 : "</span> +(num11== num12));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*第四组*/</span></span><br><span class="line">        Integer num13 = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">        Integer num14 = Integer.valueOf(<span class="number">128</span>);</span><br><span class="line">        System.out.println(<span class="string">"num13 == num14 : "</span> +(num13 == num14));</span><br><span class="line"></span><br><span class="line">        Integer num15 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">        Integer num16 = Integer.valueOf(<span class="number">127</span>);</span><br><span class="line">        System.out.println(<span class="string">"num15 == num16 : "</span> +(num15 == num16));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"></span><br><span class="line">num1 == num2 : <span class="keyword">false</span></span><br><span class="line">num3 == num4 : <span class="keyword">false</span></span><br><span class="line">num5 == num6 : <span class="keyword">false</span></span><br><span class="line">num7 == num8 : <span class="keyword">true</span></span><br><span class="line">num9 == num10 : <span class="keyword">true</span></span><br><span class="line">num11 == num12 : <span class="keyword">true</span></span><br><span class="line">num13 == num14 : <span class="keyword">false</span></span><br><span class="line">num15 == num16 : <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到尽管数字值相同，不同的创建方式比较他们的地址也不相同。</p>
<p>当我们执行<code>Integer num2 = 128;</code>就是一个自动装箱的过程，在程序<code>debug</code>过程中，自动调用了<code>Integer</code>里面的<code>valueOf</code>方法，可以看一下这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>valueOf</code>里面有一个<code>IntegerCache</code>,<code>IntegerCache</code>是<code>Integer</code>里面的私有静态内部类，下面是它的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以理解<code>IntegerCache</code>是一个缓存，它默认将-128-127之间的数字封装成对象，当我们第一次调用的时候初始化这些对象，以后我们再去装箱-128-127中间的数字直接可以从这个缓存中去取就可以了，不需要重新创建。</p>
<ul>
<li>第一组<ul>
<li>在第一种情况中，<code>num1</code>直接在堆中创建一个对象，取值128。<code>num2</code>是自动装箱的实例,因为超过缓存范围，直接创建了新的对象，所以地址是不同的。</li>
<li><code>num3</code>是直接创建出来的，<code>num4</code>是从缓存中取出来的对象，所以地址也不相同。</li>
</ul>
</li>
<li>第二组<ul>
<li>第一种情况都是超出缓存范围的情况</li>
<li>第二种在缓存中取相同的对象，所以地址相同。</li>
</ul>
</li>
<li>第三组<ul>
<li><code>num10</code>和<code>num12</code>都是基本数据类型，<code>num9</code>和<code>num11</code>自动拆箱的过程，基本数据类型比较的是值而不是地址，所以返回<code>true</code>。</li>
</ul>
</li>
<li>第四组<ul>
<li>直接调用了<code>Integer</code>的<code>valueOf</code>方法所以原理和第一组一样</li>
</ul>
</li>
</ul>
<p>缓存的好处是在大部分情况下在此范围内的“小”整数使用率比大整数要高，因此，使用相同的底层对象是有价值的，可以减少潜在的内存占用，提高程序的效率。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font color="#8B475D">总结</font></h2><ul>
<li><code>Integer num = new Integer(value)</code>不管参数的value是多少都会从堆中创建对象，与<code>IntegerCache</code>没关系。</li>
<li><code>int</code> 和 <code>Integer</code> 在进行比较的时候，<code>Integer</code> 会进行拆箱，转换为基本数据类型进行值之间的比较。</li>
<li><code>Integer</code> 与 <code>Integer</code> 比较的时候，由于直接赋值的时候会进行自动的装箱，那么这里就需要注意两个问题，一个是 -128&lt;= x&lt;=127 的整数，将会直接缓存在 <code>IntegerCache</code> 中，那么当赋值在这个区间的时候，不会创建新的 <code>Integer</code> 对象，而是从缓存中获取已经创建好的 <code>Integer</code> 对象。二：当大于这个范围的时候，直接  <code>new Integer</code> 来创建 <code>Integer</code> 对象。</li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/32/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><span class="page-number current">33</span>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="96gh'home">
            
              <p class="site-author-name" itemprop="name">96gh'home</p>
              <div class="site-description motion-element" itemprop="description">闲敲棋子落灯花</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">328</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com" title="GitHub &rarr; https://github.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/yourname" title="Weibo &rarr; https://weibo.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://stackoverflow.com/yourname" title="StackOverflow &rarr; https://stackoverflow.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/" title="blibili &rarr; "><i class="fa fa-fw fa-globe"></i>blibili</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://google.com/" title="https://google.com/" rel="noopener" target="_blank">谷歌</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://baidu.com/" title="http://baidu.com/" rel="noopener" target="_blank">百度</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://example.com/" title="http://example.com/" rel="noopener" target="_blank">友联1</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://example.com/" title="http://example.com/" rel="noopener" target="_blank">友联2</a>
                  </li>
                
              </ul>
            </div>
          

          
        </div>
      </div>

      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">96gh'home</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">859k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">13:01</span>
  
</div>








        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  





  
    
    
  
  <script color="0,0,0" opacity="0.5" zindex="-1" count="150" src="/lib/canvas-nest/canvas-nest.min.js"></script>









  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  


  
  
  

  

</body>
</html>
