<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2">



















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/ffavicon32.ico?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon32.ico?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":15,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>



  <meta name="description" content="gratitude and love">
<meta property="og:type" content="website">
<meta property="og:title" content="To be or not to be?">
<meta property="og:url" content="http://yoursite.com/page/31/index.html">
<meta property="og:site_name" content="To be or not to be?">
<meta property="og:description" content="gratitude and love">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="To be or not to be?">
<meta name="twitter:description" content="gratitude and love">



  <link rel="alternate" href="/atom.xml" title="To be or not to be?" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://yoursite.com/page/31/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>To be or not to be?</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">To be or not to be?</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">刷题学习笔记</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>about me</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



</div>
    </header>

    
  
  

  

  <a href="https://github.com/gaohanblog/gaohanblog.github.io" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/22/03-从尾到头打印链表】/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gh">
      <meta itemprop="description" content="gratitude and love">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/22/03-从尾到头打印链表】/" class="post-title-link" itemprop="url">【剑指offer 03-从尾到头打印链表】</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-22 16:54:11" itemprop="dateCreated datePublished" datetime="2019-04-22T16:54:11+08:00">2019-04-22</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-17 17:36:11" itemprop="dateModified" datetime="2019-07-17T17:36:11+08:00">2019-07-17</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/剑指offer/" itemprop="url" rel="index"><span itemprop="name">剑指offer</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">602</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">1 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p> 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>可以直接让直接让链表逆序(虽然改变了题目中链表的结构，OJ也可以通过)<br>也可以直接遍历链表把每个节点的值压入栈中，然后出栈放入list<br>因为反转链表重要一点所以本文用反转链表方式解决</p>
<h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a><font color="#8B475D">我的代码</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">     ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">     ListNode next = <span class="keyword">null</span>; </span><br><span class="line">     <span class="keyword">while</span>(listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">     	next = listNode.next;</span><br><span class="line">         listNode.next = pre;</span><br><span class="line">         pre = listNode;</span><br><span class="line">         listNode = next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>(pre != <span class="keyword">null</span>)&#123;</span><br><span class="line">       list.add(pre.val);</span><br><span class="line">       pre = pre.next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/22/02-替换字符串中的空格】/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gh">
      <meta itemprop="description" content="gratitude and love">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/22/02-替换字符串中的空格】/" class="post-title-link" itemprop="url">【剑指offer 02-替换字符串中的空格】</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-22 14:22:12" itemprop="dateCreated datePublished" datetime="2019-04-22T14:22:12+08:00">2019-04-22</time>
            </span>
          

          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/剑指offer/" itemprop="url" rel="index"><span itemprop="name">剑指offer</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">512</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">1 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p> 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/04/22/02-替换字符串中的空格】/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/22/01-二维数组中的查找】/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gh">
      <meta itemprop="description" content="gratitude and love">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/22/01-二维数组中的查找】/" class="post-title-link" itemprop="url">【剑指offer 01-二维数组中的查找】</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-22 12:54:11" itemprop="dateCreated datePublished" datetime="2019-04-22T12:54:11+08:00">2019-04-22</time>
            </span>
          

          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/剑指offer/" itemprop="url" rel="index"><span itemprop="name">剑指offer</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">618</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">1 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p> 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>一般从一个二维数组中查找一个数字都是遍历整个数组<br>因为这个数组中的列(clo)和行(row)都是有序的  所以可以直接先从第一列最后一个数字(最后一个数字在本行中最大)判断target是不是大于这个数字，target比这个元素小就往左找，比这个元素大就往下找。</p>
<h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a><font color="#8B475D">我的代码</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = array.length;</span><br><span class="line">		<span class="keyword">int</span> cols = array[<span class="number">0</span>].length;</span><br><span class="line">		<span class="keyword">int</span> i = rows - <span class="number">1</span>,j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j  &lt; cols) &#123;</span><br><span class="line">			<span class="keyword">if</span>(target &gt; array[i][j]) &#123;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[i][j]) &#123;</span><br><span class="line">				i--;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/05/12-HashMap死循环问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gh">
      <meta itemprop="description" content="gratitude and love">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/05/12-HashMap死循环问题/" class="post-title-link" itemprop="url">12-HashMap死循环问题</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-05 09:11:48" itemprop="dateCreated datePublished" datetime="2019-04-05T09:11:48+08:00">2019-04-05</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">1.9k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">2 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>JDK1.7</code>或者更老的版本中在多线程情况下是会存在死循环问题，究其原因是<code>put</code>过程中需要扩容的<code>resize</code>方法在调用<code>transfer</code>方法的时候产生了死循环。这次我们来看看到底是哪里出了问题！</p>
<h2 id="核心源码"><a href="#核心源码" class="headerlink" title="核心源码"></a><font color="#8B475D">核心源码</font></h2><p>在<code>JDK8</code>中，内部已经调整，解决了死循环问题，是如何解决的呢？将<code>JDK7</code>中头插入法改为末端插入。就是这么简单。关于这个，可以查看<code>jdk8</code>源码中的<code>resize</code>方法。</p>
<p>上面提到是由于<code>put</code>时出现问题，那么先来到<code>put()</code>中看看：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/collection/collection8-1.png" alt="image"></p>
<p>我们看到，<code>put</code>一个不存在的新元素，必然增加一个节点，我们进入这个增加节点的方法：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/collection/collection8-2.png" alt="image"></p>
<p>检查是否需要扩容，需要的话就resize:</p>
<p><img src="http://blog-picture-g.test.upcdn.net/collection/collection8-3.png" alt="image"></p>
<p>下面就是对链表数据进行迁移：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/collection/collection8-4.png" alt="image"></p>
<p>核心的代码就是这么多，首先要强调一下：<strong>假如两个线程进来，是分别建立了两个独立的扩容后的数组</strong>，比如这里是两个长度为4的数组。老的数组为2个数就是唯一的。所以在第一步，线程2运行结束时，老的数组元素已经空了。</p>
<p>下面先演示一下正常的<code>rehash</code>过程。</p>
<h2 id="单线程扩容"><a href="#单线程扩容" class="headerlink" title="单线程扩容"></a><font color="#8B475D">单线程扩容</font></h2><p><img src="http://blog-picture-g.test.upcdn.net/collection/collection8-5.png" alt="image"></p>
<ul>
<li>假设了我们的<code>hash</code>算法就是简单的用<code>key mod</code> 一下数组(<code>hash</code>表)的大小</li>
<li>最上面的是<code>old hash</code>表，其中的<code>Hash</code>表的<code>size=2</code>, 所以<code>key = 3, 7, 5</code>，在<code>mod 2</code>以后都冲突在<code>table[1]</code>这里了。</li>
<li>接下来的三个步骤是<code>Hash</code>表 <code>resize</code> 成4，然后所有的 <code>&lt;key,value&gt;</code> 重新 <code>rehash</code> 的过程</li>
</ul>
<p>注意到，在<code>JDK7</code>中，是按照头插入法依次插入的。所以7插到了3前面。这也是引起死锁的原因。</p>
<h2 id="并发情况"><a href="#并发情况" class="headerlink" title="并发情况"></a><font color="#8B475D">并发情况</font></h2><h5 id="初始情况"><a href="#初始情况" class="headerlink" title="#初始情况"></a>#<font color="#367bdd">初始情况</font></h5><p>假设我们有两个线程。我用红色和浅蓝色标注了一下。</p>
<p>对于第一个线程先执行完这一行，然后挂起，此时 <code>e</code>和 <code>next</code> 都附好值了：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/collection/collection8-6.png" alt="image"></p>
<p>而让线程二执行完成。于是我们有下面的这个样子：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/collection/collection8-7.png" alt="image"></p>
<p>因为线程一的 <code>e</code> 指向了<code>key(3)</code> ，而 <code>next</code> 指向了 <code>key(7)</code> ，其在 <code>Thread2</code> <code>rehash</code>后，指向了<code>Thread2</code> 重组后的链表。</p>
<h5 id="Thread1被调度回来继续执行"><a href="#Thread1被调度回来继续执行" class="headerlink" title="#Thread1被调度回来继续执行"></a>#<font color="#367bdd">Thread1被调度回来继续执行</font></h5><ul>
<li><p>先是执行 <code>newTalbe[i] = e</code> ：此时线程1的第三个位置就是指向元素3;</p>
</li>
<li><p>然后是 <code>e = next</code>，导致了 <code>e</code>指向了 <code>key(7)</code>;</p>
</li>
<li><p>而下一次循环的 <code>next = e.next</code> 导致了 <code>next</code> 指向了 <code>key(3)</code> ;</p>
<p><img src="http://blog-picture-g.test.upcdn.net/collection/collection8-8.png" alt="image"></p>
</li>
</ul>
<p>接下来线程一继续工作，把<code>key(7)</code>摘下来，放到<code>newTable[i]</code>的第一个,然后把<code>e</code>和<code>next</code>向下移动。</p>
<p><img src="http://blog-picture-g.test.upcdn.net/collection/collection8-9.png" alt="image"></p>
<h5 id="环形链接出现"><a href="#环形链接出现" class="headerlink" title="#环形链接出现"></a>#<font color="#367bdd">环形链接出现</font></h5><p>在上面再执行<code>e.next = newTable[i]</code> 导致 <code>key(3).next</code> 指向了 <code>key(7)</code>，<strong>但是由于线程二已经改变了<code>key(7)</code>的指向此时的 <code>key(7).next</code> 已经指向了 <code>key(3)</code></strong>， 环形链表就这样出现了。</p>
<p><img src="http://blog-picture-g.test.upcdn.net/collection/collection8-10.png" alt="image"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font color="#8B475D">总结</font></h2><p>这个过程还是比较绕的，主要两个线程同时操作同一个链表节点的指向的时候，不能同步更新的话，会出错。我们简单梳理一下上面的过程。</p>
<h5 id="初始状态"><a href="#初始状态" class="headerlink" title="#初始状态"></a>#<font color="#367bdd">初始状态</font></h5><ul>
<li>线程一： <code>e -&gt; key3</code> , <code>next -&gt; key7</code></li>
<li>线程二： 数组3号位置 <code>arr2[3] -&gt; key7 -&gt; key3</code></li>
</ul>
<p>注意此时 key7 指向 key3 .</p>
<h5 id="线程一继续执行"><a href="#线程一继续执行" class="headerlink" title="#线程一继续执行"></a>#<font color="#367bdd">线程一继续执行</font></h5><p><img src="http://blog-picture-g.test.upcdn.net/collection/collection8-11.png" alt="image"></p>
<ul>
<li><code>i = 3</code></li>
<li><code>e.next = key7</code>,此时 <code>e=key3</code> ,所以是 <code>key3.next = key7</code>（这是线程1的初始状态决定的）</li>
<li><code>arr1[3]</code> 指向 <code>key3</code></li>
<li><code>e</code>为 <code>key7</code></li>
</ul>
<h5 id="由于e不为空，所以还会循环："><a href="#由于e不为空，所以还会循环：" class="headerlink" title="#由于e不为空，所以还会循环："></a>#<font color="#367bdd">由于e不为空，所以还会循环：</font></h5><ul>
<li>上一步 <code>e</code>为 <code>key7</code>，所以 <code>next = key7.next</code>，到线程2中一看是<code>key3</code>，所以 <code>next = key3</code>（线程2中<code>key7.next</code>就是<code>key3</code>）</li>
<li><code>i = 3</code></li>
<li><code>e.next = key3</code>——注意，这里就是<code>Key7</code>指向了<code>key3</code>,<code>key7</code>的<code>next</code>引用下面没有变过，所以这里做一下记录，即<code>key7</code>指向<code>key3</code></li>
<li><code>newTable[3] = key7</code></li>
<li><code>e = key3</code></li>
</ul>
<h5 id="由于e不为空，所以还会循环：-1"><a href="#由于e不为空，所以还会循环：-1" class="headerlink" title="#由于e不为空，所以还会循环："></a>#<font color="#367bdd">由于e不为空，所以还会循环：</font></h5><ul>
<li>上一步<code>e=key3</code>, <code>next=null</code></li>
<li><code>i=3</code></li>
<li><code>key3.next = key7</code>，注意,由于<code>key7</code>已经指向了<code>key3</code>，此时<code>key3</code>又指向<code>key7</code>,发生死循环</li>
<li><code>newTable[3] = key3</code></li>
<li><code>e = null</code></li>
</ul>
<h5 id="e为null，跳出循环。"><a href="#e为null，跳出循环。" class="headerlink" title="#e为null，跳出循环。"></a>#<font color="#367bdd">e为null，跳出循环。</font></h5><p>此时发现<code>key3</code>又指向了<code>key7</code>。发生死循环。</p>
<p><strong>注意此时程序并没有发生死循环，只有在其他程序用到遍历链表时，才会进入死循环。</strong></p>
<p>整理自：</p>
<ul>
<li><a href="https://coolshell.cn/articles/9606.html/comment-page-2#comments" target="_blank" rel="noopener">疫苗：JAVA HASHMAP的死循环</a></li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/03/11-ConcurrentHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gh">
      <meta itemprop="description" content="gratitude and love">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/03/11-ConcurrentHashMap/" class="post-title-link" itemprop="url">11-ConcurrentHashMap</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-03 11:53:48" itemprop="dateCreated datePublished" datetime="2019-04-03T11:53:48+08:00">2019-04-03</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">5.7k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">5 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于并发场景下，推荐使用线程安全的 <code>concurrentHashMap</code> ，而不是 <code>HashMap</code> 或者是 <code>HashTable</code> ,<code>concurrentHashMap</code>在<code>JDK7</code>和<code>JDK8</code>中的实现原理是不一样的。本文我们来看一下<code>concurrentHashMap</code>的原理。</p>
<h2 id="JDK7实现"><a href="#JDK7实现" class="headerlink" title="JDK7实现"></a><font color="#8B475D">JDK7实现</font></h2><p><code>ConcurrentHashMap</code> 的内部细分了若干个小的 <code>HashMap</code> ，称之为段（ <code>SEGMENT</code> ）。 <code>ConcurrentHashMap</code> 是一个 <code>Segment</code> 数组，<code>Segment</code> 通过继承 <code>ReentrantLock</code> 来进行加锁，所以每次需要加锁的操作锁住的是一个 <code>segment</code> ，这样只要保证每个 <code>Segment</code> 是线程安全的，也就实现了全局的线程安全。</p>
<p><img src="http://blog-picture-g.test.upcdn.net/collection/collection7-1.png" alt="image"></p>
<p>如图所示，是由 <code>Segment</code> 数组、<code>HashEntry</code> 数组组成，和 <code>HashMap</code> 一样，仍然是数组加链表组成。</p>
<p><code>ConcurrentHashMap</code> 采用了分段锁技术，其中 <code>Segment</code> 继承于 <code>ReentrantLock</code>。不会像<code>HashTable</code> 那样不管是 <code>put</code> 还是 <code>get</code> 操作都需要做同步加锁处理，理论上 <code>ConcurrentHashMap</code> 支持 <code>CurrencyLevel</code>( <code>Segment</code> 数组数量)的线程并发。每当一个线程占用锁访问一个 <code>Segment</code> 时，不会影响到其他的 <code>Segment</code>。</p>
<h5 id="get方法"><a href="#get方法" class="headerlink" title="#get方法"></a>#<font color="#367bdd">get方法</font></h5><p><code>ConcurrentHashMap</code> 的 <code>get</code> 方法是非常高效的，<strong>因为整个过程都不需要加锁。</strong></p>
<p>只需要将<code>Key</code>通过<code>Hash</code> 之后定位到具体的 <code>Segment</code> ，再通过一次 <code>Hash</code> 定位到具体的元素上。由于 <code>HashEntry</code> 中的 <code>value</code>属性是用 <code>volatile</code>关键词修饰的，保证了内存可见性，所以每次获取时都是最新值.</p>
<p>内部 <code>HashEntry</code> 类 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="put方法"><a href="#put方法" class="headerlink" title="#put方法"></a>#<font color="#367bdd">put方法</font></h5><p>虽然 <code>HashEntry</code> 中的 <code>value</code> 是用 <code>volatile</code> 关键词修饰的，但是并不能保证并发的原子性，所以 <code>put</code> 操作时仍然需要加锁处理。</p>
<p>首先也是通过<code>Key</code>的 <code>Hash</code> 定位到具体的<code>Segment</code>，在 <code>put</code> 之前会进行一次扩容校验。这里比 <code>HashMap</code> 要好的一点是：<code>HashMap</code> 是插入元素之后再看是否需要扩容，有可能扩容之后后续就没有插入就浪费了本次扩容(扩容非常消耗性能)。</p>
<p>而 <code>ConcurrentHashMap</code> 不一样，它是在将数据插入之前检查是否需要扩容，之后再做插入操作。</p>
<h5 id="size方法"><a href="#size方法" class="headerlink" title="#size方法"></a>#<font color="#367bdd">size方法</font></h5><p>每个 <code>Segment</code> 都有一个 <code>volatile</code> 修饰的全局变量 <code>count</code> ,求整个 <code>ConcurrentHashMap</code> 的 <code>size</code> 时很明显就是将所有的 <code>count</code> 累加即可。但是 <code>volatile</code> 修饰的变量却不能保证多线程的原子性，所有直接累加很容易出现并发问题。</p>
<p>但如果每次调用 <code>size</code> 方法将其余的修改操作加锁效率也很低。所以做法是先尝试两次将 <code>count</code> 累加，如果容器的 <code>count</code> 发生了变化再加锁来统计 <code>size</code>。</p>
<p>在<code>JDK7</code> 中，第一种方案他会使用不加锁的模式去尝试多次计算 <code>ConcurrentHashMap</code> 的 <code>size</code>，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的。</p>
<p>第二种方案是如果第一种方案不符合，他就会给每个<code>Segment</code> 加上锁，然后计算 <code>ConcurrentHashMap</code> 的 <code>size</code> 返回。其源码实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line"> <span class="keyword">int</span> size;</span><br><span class="line"> <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line"> <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line"> <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line"> <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">0L</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    overflow = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">        <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sum += seg.modCount;</span><br><span class="line">            <span class="keyword">int</span> c = seg.count;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">            overflow = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == last)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        last = sum; </span><br><span class="line">    &#125;</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">            segmentAt(segments, j).unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁之前重试次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h2 id="JDK8实现"><a href="#JDK8实现" class="headerlink" title="JDK8实现"></a><font color="#8B475D">JDK8实现</font></h2><p><img src="http://blog-picture-g.test.upcdn.net/collection/collection7-2.png" alt="image"></p>
<p><code>jdk8</code> 中的 <code>ConcurrentHashMap</code> 数据结构和实现与 jdk7 还是有着明显的差异。</p>
<p>其中抛弃了原有的 <code>Segment</code> 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p>
<p>也将<code>jdk7</code>中存放数据的<code>HashEntry</code> 改为 <code>Node</code>，但作用都是相同的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="keyword">volatile</span> V val;</span><br><span class="line">       <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.val = val;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + val; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h5 id="put方法-1"><a href="#put方法-1" class="headerlink" title="#put方法"></a>#<font color="#367bdd">put方法</font></h5><p>重点我们来看下<code>put</code>方法。</p>
<p><img src="http://blog-picture-g.test.upcdn.net/collection/collection7-3.jpg" alt="image"></p>
<ul>
<li>根据 <code>key</code> 计算出 <code>hashcode</code> 。</li>
<li>判断是否需要进行初始化。</li>
<li><code>f</code>即为当前 <code>key</code> 定位出的 <code>Node</code>，如果为空表示当前位置可以写入数据，利用 <code>CAS</code> 尝试写入，失败则自旋保证成功。</li>
<li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li>
<li>如果都不满足(不需要初始化、Node不为空、不需要扩容)，则利用 <code>synchronized</code> 锁写入数据。</li>
<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li>
</ul>
<h5 id="get方法-1"><a href="#get方法-1" class="headerlink" title="#get方法"></a>#<font color="#367bdd">get方法</font></h5><ul>
<li>根据计算出来的 <code>hashcode</code> 寻址，如果就在桶上那么直接返回值。</li>
<li>如果是红黑树那就按照树的方式获取值。</li>
<li>都不满足那就按照链表的方式遍历获取值。</li>
</ul>
<h5 id="size方法-1"><a href="#size方法-1" class="headerlink" title="#size方法"></a>#<font color="#367bdd">size方法</font></h5><p><code>JDK8</code>实现相比<code>JDK7</code> 简单很多，只有一种方案，我们直接看 <code>size()</code>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = sumCount();</span><br><span class="line">        <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">                (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">                (<span class="keyword">int</span>)n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CounterCell[] as = counterCells; </span><br><span class="line">        CounterCell a;</span><br><span class="line">        <span class="comment">//获取baseCount值</span></span><br><span class="line">        <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">        <span class="comment">//遍历CounterCell数组全部加到baseCount上，它们的和就是size</span></span><br><span class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                    sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可能你会有所疑问，<code>ConcurrentHashMap</code> 中的 <code>baseCount</code> 属性不就是记录的所有键值对的总数吗？直接返回它不就行了吗？</p>
<p>之所以没有这么做，是因为我们的 <code>addCount</code> 方法用于 <code>CAS</code>更新 <code>baseCount</code>，但很有可能在高并发的情况下，更新失败，那么这些节点虽然已经被添加到哈希表中了，但是数量却没有被统计。</p>
<p>还好，<code>addCount</code>方法在更新<code>baseCount</code> 失败的时候，会调用<code>fullAddCount</code> 将这些失败的结点包装成一个 <code>CounterCell</code>对象，保存在 <code>CounterCell</code> 数组中。那么整张表实际的 <code>size</code> 其实是 <code>baseCount</code> 加上 <code>CounterCell</code>数组中元素的个数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font color="#8B475D">总结</font></h2><ul>
<li>并发情况下请使用<code>concurrentHashMap</code></li>
<li>在<code>jdk7</code>中，用的是分段锁，默认是12段，那么并发量最多也就12.<ul>
<li><code>get</code>不加锁，第一次<code>hash</code>定位到<code>segment</code>，第二次<code>hash</code>定位到元素，元素值是用<code>volatile</code>保证内存可见性。</li>
<li><code>put</code>需要加锁，<code>hash</code>定位到<code>segment</code>后，先检查是否需要扩容再插入。</li>
<li><code>size</code>先使用不加锁的模式去尝试多次计算<code>size</code>，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入；如果不一致，给每个 <code>Segment</code> 加上锁再依次去计算个数</li>
</ul>
</li>
<li>在<code>jdk8</code>中，采用了<code>CAS + synchronized</code>来保证并发安全性<ul>
<li><code>put</code>的过程比较复杂 简单来说主要通过下面这几个阶段。先计算<code>hash</code>定位到<code>node</code>—&gt;判断是否需要初始化—&gt;如果<code>node</code>为空则表示可以插入，用<code>cas</code>插入—&gt;判断是否需要扩容—&gt;如果不需要初始化，Node不为空还需要判断是否需要扩容—&gt;则用<code>synchorized</code>锁写入数据—&gt;判断是否需要转换成红黑树。</li>
<li><code>get</code>就比较简单，直接根据<code>hash</code>定位到<code>node</code>，然后以链表或者红黑树的方式拿到.</li>
<li><code>size</code>方法就一种方案：<code>baseCount+CounterCell[]</code>中所有元素</li>
</ul>
</li>
</ul>
<p>整理自：</p>
<p><a href="https://crossoverjie.top/JCSprout/#/thread/ConcurrentHashMap?id=size-%e6%96%b9%e6%b3%95" target="_blank" rel="noopener">ConcurrentHashMap 实现原理</a></p>
<p><a href="https://www.jianshu.com/p/e99e3fcface4" target="_blank" rel="noopener">为并发而生的 ConcurrentHashMap（Java 8）</a></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/10-LinkedHashSet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gh">
      <meta itemprop="description" content="gratitude and love">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/01/10-LinkedHashSet/" class="post-title-link" itemprop="url">10-LinkedHashSet</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-01 15:32:48" itemprop="dateCreated datePublished" datetime="2019-04-01T15:32:48+08:00">2019-04-01</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">1.5k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">1 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>HashSet</code> 和 <code>LinkedHashSet</code> 的关系类似于 <code>HashMap</code> 和 <code>LinkedHashMap</code> 的关系，即后者维护双向链表，实现迭代顺序可为插入顺序或是访问顺序。所以也就轻松加愉快快速了解一下即可。</p>
<h2 id="继承关系和属性"><a href="#继承关系和属性" class="headerlink" title="继承关系和属性"></a><font color="#8B475D">继承关系和属性</font></h2><p>从源码中可以看到其空的构造函数为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>super</code>即父类是<code>HashSet</code>，从它的继承关系就可以显然看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p> 那么<code>HashSet</code>内部的数据结构就是一个 <code>HashMap</code>，其方法的内部几乎就是在调用<code>HashMap</code> 的方法。</p>
<p><code>LinkedHashSet</code> 首先我们需要知道的是它是一个 <code>Set</code> 的实现，所以它其中存的肯定不是键值对，而是值。此实现与 <code>HashSet</code> 的不同之处在于，<code>LinkedHashSet</code> 维护着一个运行于所有条目的双向循环链表。</p>
<p>这一切都与<code>LinkedHashMap</code>类似。</p>
<p><code>LinkedHashSet</code>内部有个属性 <code>accessOrder</code> 控制着遍历次序。默认情况下该值为 <code>false</code> ,即按插入排序访问。如果将该值设置为 <code>true</code> 的话，则按访问次序排序(即最近最少使用算法，最近最少使用的放在链表头部，最近访问的则在链表尾部)。</p>
<h2 id="小栗子"><a href="#小栗子" class="headerlink" title="小栗子"></a><font color="#8B475D">小栗子</font></h2><h5 id="HashSet的遍历"><a href="#HashSet的遍历" class="headerlink" title="#HashSet的遍历"></a>#<font color="#367bdd">HashSet的遍历</font></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Set&lt;String&gt; linkedHashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	linkedHashSet.add(<span class="string">"aaa"</span>);</span><br><span class="line">	linkedHashSet.add(<span class="string">"eee"</span>);</span><br><span class="line">	linkedHashSet.add(<span class="string">"ccc"</span>);</span><br><span class="line">	linkedHashSet.add(<span class="string">"bbb"</span>);</span><br><span class="line">	</span><br><span class="line">	Iterator&lt;String&gt; it = linkedHashSet.iterator();</span><br><span class="line">	<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">		System.out.println(it.next());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">ccc</span><br><span class="line">bbb</span><br><span class="line">eee</span><br></pre></td></tr></table></figure>

<h5 id="LinkedHashSet的遍历"><a href="#LinkedHashSet的遍历" class="headerlink" title="#LinkedHashSet的遍历"></a>#<font color="#367bdd">LinkedHashSet的遍历</font></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Set&lt;String&gt; linkedHashSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	linkedHashSet.add(<span class="string">"aaa"</span>);</span><br><span class="line">	linkedHashSet.add(<span class="string">"eee"</span>);</span><br><span class="line">	linkedHashSet.add(<span class="string">"ccc"</span>);</span><br><span class="line">	linkedHashSet.add(<span class="string">"bbb"</span>);</span><br><span class="line">	linkedHashSet.add(<span class="keyword">null</span>);</span><br><span class="line">	</span><br><span class="line">	Iterator&lt;String&gt; it = linkedHashSet.iterator();</span><br><span class="line">	<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">		System.out.println(it.next());</span><br><span class="line">	&#125;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eee</span><br><span class="line">ccc</span><br><span class="line">bbb</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>可以看到与输入顺序是一致的。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/29/09-Hashtable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gh">
      <meta itemprop="description" content="gratitude and love">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/29/09-Hashtable/" class="post-title-link" itemprop="url">09-Hashtable</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-29 18:33:48" itemprop="dateCreated datePublished" datetime="2019-03-29T18:33:48+08:00">2019-03-29</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">8.9k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">8 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>Hashtable</code> 是个过时的集合类，不建议在新代码中使用，不需要线程安全的场合可以用 <code>HashMap</code> 替换，需要线程安全的场合可以用 <code>ConcurrentHashMap</code> 替换，需要排序的集合类，可以用<code>LinkedHashMap</code>。但这并不是我们不去了解它的理由。最起码 <code>Hashtable</code> 和 <code>HashMap</code> 的面试题可能会用到。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><font color="#8B475D">前言</font></h2><p><code>Hashtable</code>和<code>HashMap</code>，从存储结构和实现来讲基本上都是相同的。</p>
<p>它和<code>HashMap</code>的最大的不同是它是线程安全的，另外它不允许<code>key</code>和<code>value</code>为<code>null</code>。</p>
<p>为了能在哈希表中成功地保存和取出对象，用作<code>key</code>的对象必须实现<code>hashCode</code>方法和<code>equals</code>方法。</p>
<h2 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a><font color="#8B475D">fail-fast</font></h2><p><code>iterator</code>方法返回的迭代器是<code>fail-fast</code>的。如果在迭代器被创建后<code>hashtable</code>被结构型地修改了，除了迭代器自己的<code>remove</code>方法，迭代器会抛出一个<code>ConcurrentModificationException</code>异常。</p>
<p><strong>因此，面对在并发的修改，迭代器直接异常停止，不会再尝试其他方法。</strong></p>
<p>关于这个的理解，其实在上一节讲<code>LinkedHashMap</code>中提到过：</p>
<p><strong>值得注意的是，<code>afterNodeAccess()</code> 函数中，会修改<code>modCount</code>,因此当你正在<code>accessOrder=true的</code>模式下,迭代<code>LinkedHashMap</code>时，如果同时查询访问数据，也会导致<code>fail-fast</code>，因为迭代的顺序已经改变。</strong></p>
<p>简单说，就是两个线程同时分别进行修改和遍历时，会抛出这个异常。</p>
<h5 id="集合在遍历过程中是否可以删除元素，为什么迭代器就可以安全删除元素？"><a href="#集合在遍历过程中是否可以删除元素，为什么迭代器就可以安全删除元素？" class="headerlink" title="#集合在遍历过程中是否可以删除元素，为什么迭代器就可以安全删除元素？"></a>#<font color="#367bdd">集合在遍历过程中是否可以删除元素，为什么迭代器就可以安全删除元素？</font></h5><p>集合在使用 <code>for</code> 循环迭代的过程中不允许使用，集合本身的 <code>remove</code>方法删除元素，如果进行错误操作将会导致 <code>ConcurrentModificationException</code> 异常的发生.</p>
<p><code>Iterator</code>可以删除访问的当前元素(<code>current</code>)，一旦删除的元素是<code>Iterator</code> 对象中 <code>next</code> 所正在引用的，在 <code>Iterator</code> 删除元素通过 修改 <code>modCount</code> 与 <code>expectedModCount</code> 的值，可以使下次在调用 <code>remove</code> 的方法时候两者仍然相同因此不会有异常产生。</p>
<p>迭代器的<code>fail-fast</code>机制并不能得到保证，它不能够保证一定出现该错误。一般来说，<code>fail-fast</code>会尽最大努力抛出<code>ConcurrentModificationException</code>异常。因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：<code>ConcurrentModificationException</code> 应该仅用于检测 <code>bug</code>。</p>
<p><code>Hashtable</code>是线程安全的。如果不需要线程安全的实现是不需要的，推荐使用<code>HashMap</code>代替<code>Hashtable</code>。如果需要线程安全的实现，推荐使用<code>ConcurrentHashMap</code>代替<code>Hashtable</code>。</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a><font color="#8B475D">继承关系</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;  </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;  </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>extends Dictionary&lt;K,V&gt;：Dictionary</code>类是一个抽象类，用来存储键/值对，作用和<code>Map</code>类相似。</li>
<li><code>implements Map&lt;K,V&gt;</code>：实现了<code>Map</code>，实现了<code>Map</code>中声明的操作和<code>default</code>方法。</li>
</ul>
<p><code>hashMap</code>以及<code>TreeMap</code>的源码，都没有继承于这个类。不过当我看到注释中的解释也就明白了，其<code>Dictionary</code> 源码注释是这样的：<code>NOTE: This class is obsolete. New implementations should implement the Map interface, rather than extending this class.</code>该话指出 <code>Dictionary</code> 这个类过时了，新的实现类应该实现Map接口。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a><font color="#8B475D">属性</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录哈希表中键值对的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容的阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hashtable被结构型修改的次数。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><code>HashTable</code>并没有像<code>HashMap</code>那样定义了很多的常量，而是直接写死在了方法里。</p>
<p><code>Hashtable</code>不要求底层数组的容量一定要为2的整数次幂，而<code>HashMap</code>则要求一定为2的整数次幂。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><font color="#8B475D">构造函数</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用默认初始化容量（11）和默认负载因子（0.75）来构造一个空的hashtable.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这里可以看到，Hashtable默认初始化容量为16，而HashMap的默认初始化容量为11。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以获取到这些信息：<code>HashTable</code>默认的初始化容量为<code>11</code>（与<code>HashMap</code>不同），负载因子默认为0.75（与<code>HashMap</code>相同）。而正因为默认初始化容量的不同，同时也没有对容量做调整的策略，所以可以先推断出，<code>HashTable</code>使用的哈希函数跟<code>HashMap</code>是不一样的（事实也确实如此）。</p>
<h2 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a><font color="#8B475D">重要方法</font></h2><h5 id="get方法"><a href="#get方法" class="headerlink" title="#get方法"></a>#<font color="#367bdd">get方法</font></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">//通过哈希函数，计算出key对应的桶的位置</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="comment">//遍历该桶的所有元素，寻找该key</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，<code>Hashtable</code>和<code>HashMap</code>确认<code>key</code>在数组中的索引的方法不同。</p>
<ul>
<li><code>Hashtable</code>通过<code>index = (hash &amp; 0x7FFFFFFF) % tab.length</code>;来确认</li>
<li><code>HashMap</code>通过<code>i = (n - 1) &amp; hash</code>;来确认</li>
</ul>
<h5 id="put方法"><a href="#put方法" class="headerlink" title="#put方法"></a>#<font color="#367bdd">put方法</font></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确认value不为null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">//找到key在table中的索引</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">//获取key所在索引的entry</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="comment">//遍历entry，判断key是否已经存在</span></span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="comment">//如果key已经存在</span></span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            <span class="comment">//保存旧的value</span></span><br><span class="line">            V old = entry.value;</span><br><span class="line">            <span class="comment">//替换value</span></span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="comment">//返回旧的value</span></span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果key在hashtable不是已经存在，就直接将键值对添加到table中，返回null</span></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">//哈希表的键值对个数达到了阈值，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">        <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab = table;</span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    <span class="comment">//把新节点插入桶中（头插法）</span></span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以总结出<code>Hashtable</code>的<code>put</code>方法的总体思路：</p>
<ul>
<li>确认<code>value</code>不为<code>null</code>。如果为<code>null</code>，则抛出异常</li>
<li>找到<code>key</code>在<code>table</code>中的索引，获取<code>key</code>所在位置的<code>entry</code></li>
<li>遍历<code>entry</code>，判断<code>key</code>是否已经存在<br>如果<code>key</code>已经存在，替换<code>value</code>，返回旧的<code>value</code></li>
<li>如果<code>key</code>在<code>hashtable</code>不是已经存在，就直接添加，否则直接将键值对添加到<code>table</code>中，返回<code>null</code></li>
</ul>
<p>在方法中可以看到，在遍历桶中元素时，是按照链表的方式遍历的。可以印证，<code>HashMap</code>的桶中可能为链表或者树。但<code>Hashtable</code>的桶中只可能是链表。</p>
<h5 id="remove方法"><a href="#remove方法" class="headerlink" title="#remove方法"></a>#<font color="#367bdd">remove方法</font></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">//计算key在hashtable中的索引</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="comment">//遍历entry，如果entry中存在key为参数key的键值对，就删除键值对，并返回键值对的value</span></span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不存在key为参数key的键值对，返回value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以总结出<code>Hashtable</code>的<code>remove</code>方法的总体思路：</p>
<ul>
<li>找到<code>key</code>在<code>table</code>中的索引，获取<code>key</code>所在位置的<code>entry</code></li>
<li>遍历<code>entry</code>，判断<code>key</code>是否已经存在</li>
<li>如果<code>key</code>存在，删除<code>key</code>映射的键值对，返回旧的<code>value</code></li>
<li>如果<code>key</code>在<code>hashtable</code>不存在，返回<code>null</code></li>
</ul>
<h5 id="rehash方法"><a href="#rehash方法" class="headerlink" title="#rehash方法"></a>#<font color="#367bdd">rehash方法</font></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加hashtable的容量，为了更有效地存放和找到它的entry。</span></span><br><span class="line"><span class="comment"> * 当键值对的数量超过了临界值（capacity*load factor）这个方法自动调用</span></span><br><span class="line"><span class="comment"> * 长度变为原来的2倍+1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录旧容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">    <span class="comment">//记录旧桶的数组</span></span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">//新的容量为旧的容量的2倍+1</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果新的容量大于容量的最大值MAX_ARRAY_SIZE </span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果旧容量为MAX_ARRAY_SIZE，容量不变，中断方法的执行</span></span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果旧容量不为MAX_ARRAY_SIZE，新容量变为MAX_ARRAY_SIZE</span></span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建新的数组，容量为新容量</span></span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line">    <span class="comment">//结构性修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//计算扩容的临界值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    table = newMap;</span><br><span class="line">    <span class="comment">//将旧的数组中的键值对转移到新数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完代码，我们可以总结出<code>rehash</code>的总体思路为：</p>
<ul>
<li>新建变量新的容量，值为旧的容量的2倍+1</li>
<li>如果新的容量大于容量的最大值<code>MAX_ARRAY_SIZE</code>。<ul>
<li>如果旧容量为<code>MAX_ARRAY_SIZE</code>，容量不变，中断方法的执行</li>
<li>如果旧容量不为<code>MAX_ARRAY_SIZE</code>，新容量变为<code>MAX_ARRAY_SIZE</code>。</li>
</ul>
</li>
<li>创建新的数组，容量为新容量</li>
<li>将旧的数组中的键值对转移到新数组中</li>
</ul>
<p>这里可以看到，一般情况下，<code>HashMap</code>扩容后容量变为原来的两倍，而<code>Hashtable</code>扩容后容量变为原来的两倍加一。</p>
<p><strong><code>HashTable</code>的<code>rehash</code>方法相当于<code>HashMap</code>的<code>resize</code>方法。跟<code>HashMap</code>那种巧妙的<code>rehash</code>方式相比，<code>HashTable</code>的<code>rehash</code>过程需要对每个键值对都重新计算哈希值，而比起异或和与操作，取模是一个非常耗时的操作，所以这也是导致效率较低的原因之一。</strong></p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a><font color="#8B475D">遍历</font></h2><p>可以使用与<code>HashMap</code>一样的遍历方式，但是由于历史原因，多了<code>Enumeration</code>的方式。</p>
<p>针对<code>Enumeration</code>，这里与<code>iterator</code>进行对比一下。</p>
<p>#相同点:</p>
<ul>
<li><code>Iterator</code>和<code>Enumeration</code>都可以对某些容器进行遍历。</li>
<li><code>Iterator</code>和<code>Enumeration</code>都是接口。</li>
</ul>
<p>#不同点:</p>
<ul>
<li><code>Iterator</code>有对容器进行修改的方法。而<code>Enumeration</code>只能遍历。</li>
<li><code>Iterator</code>支持<code>fail-fast</code>，而<code>Enumeration</code>不支持。</li>
<li><code>Iterator</code>比<code>Enumeration</code>覆盖范围广，基本所有容器中都有<code>Iterator</code>迭代器，而只有<code>Vector</code>、<code>Hashtable</code>有<code>Enumeration</code>。</li>
<li><code>Enumeration</code>在JDK 1.0就已经存在了，而<code>Iterator</code>是JDK2.0新加的接口。</li>
</ul>
<h2 id="Hashtable与HashMap对比"><a href="#Hashtable与HashMap对比" class="headerlink" title="Hashtable与HashMap对比"></a><font color="#8B475D">Hashtable与HashMap对比</font></h2><p><code>HashTable</code>的应用非常广泛，<code>HashMap</code>是新框架中用来代替<code>HashTable</code>的类，也就是说建议使用<code>HashMap</code>，下面着重比较一下二者的区别。</p>
<h5 id="继承不同"><a href="#继承不同" class="headerlink" title="#继承不同"></a>#<font color="#367bdd">继承不同</font></h5><p><code>Hashtable</code>是基于陈旧的<code>Dictionary</code>类的，<code>HashMap</code>是<code>java1.2</code>引进的<code>Map</code>接口的一个实现。</p>
<h5 id="同步"><a href="#同步" class="headerlink" title="#同步"></a>#<font color="#367bdd">同步</font></h5><p><code>Hashtable</code> 中的方法是同步的，保证了<code>Hashtable</code>中的对象是线程安全的。</p>
<p><code>HashMap</code>中的方法在缺省情况下是非同步的,<code>HashMap</code>中的对象并不是线程安全的。在多线程并发的环境下，可以直接使用<code>Hashtable</code>，但是要使用<code>HashMap</code>的话就要自己增加同步处理了。</p>
<h5 id="效率"><a href="#效率" class="headerlink" title="#效率"></a>#<font color="#367bdd">效率</font></h5><p>单线程中, <code>HashMap</code>的效率大于<code>Hashtable</code>。因为同步的要求会影响执行的效率，所以如果你不需要线程安全的集合，<code>HashMap</code>是<code>Hashtable</code>的轻量级实现，这样可以避免由于同步带来的不必要的性能开销，从而提高效率。</p>
<h5 id="null值"><a href="#null值" class="headerlink" title="#null值"></a>#<font color="#367bdd">null值</font></h5><p><code>Hashtable</code>中，<code>key</code>和<code>value</code>都不允许出现<code>null</code>值，否则出现<code>NullPointerException</code>。</p>
<p>在<code>HashMap</code>中，<code>null</code>可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为<code>null</code>。当<code>get()</code>方法返回<code>null</code>值时，即可以表示 <code>HashMap</code>中没有该键，也可以表示该键所对应的值为<code>null</code>。因此，<strong>在<code>HashMap</code>中不能由<code>get()</code>方法来判断<code>HashMap</code>中是否存在某个键，而应该用<code>containsKey()</code>方法来判断。</strong></p>
<h5 id="遍历方式"><a href="#遍历方式" class="headerlink" title="#遍历方式"></a>#<font color="#367bdd">遍历方式</font></h5><p><code>Hashtable</code>、<code>HashMap</code>都使用了 <code>Iterator</code>。而由于历史原因，<code>Hashtable</code>可以使用<code>Enumeration</code>的方式。</p>
<h5 id="容量"><a href="#容量" class="headerlink" title="#容量"></a>#<font color="#367bdd">容量</font></h5><p><code>Hashtable</code>和<code>HashMap</code>它们两个内部实现方式的数组的初始大小和扩容的方式。</p>
<p><code>HashTable</code>中<code>hash</code>数组默认大小是11，增加的方式是 <code>old*2+1</code>。</p>
<p><code>HashMap</code>中<code>hash</code>数组的默认大小是16，而且一定是2的指数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font color="#8B475D">总结</font></h2><p>无论什么时候有多个线程访问相同实例的可能时，就应该使用<code>Hashtable</code>，反之使用<code>HashMap</code>。非线程安全的数据结构能带来更好的性能。</p>
<p>如果在将来有一种可能—你需要按顺序获得键值对的方案时，<code>HashMap</code>是一个很好的选择，因为有<code>HashMap</code>的一个子类 <code>LinkedHashMap</code>。</p>
<p>所以如果你想可预测的按顺序迭代（默认按插入的顺序），你可以很方便用<code>LinkedHashMap</code>替换<code>HashMap</code>。反观要是使用的<code>Hashtable</code>就没那么简单了。</p>
<p>如果有多个线程访问<code>HashMap</code>，<code>Collections.synchronizedMap（）</code>可以代替，总的来说<code>HashMap</code>更灵活，或者直接用并发容器<code>ConcurrentHashMap</code>。</p>
<p>整理自：</p>
<ul>
<li><a href="https://blog.csdn.net/panweiwei1994/article/details/77428710" target="_blank" rel="noopener">Java8源码-Hashtable（2）</a></li>
<li><a href="https://blog.csdn.net/u013124587/article/details/52655042" target="_blank" rel="noopener">Java8 - HashTable源码</a></li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/27/08-HashMap和LinkedHashMap遍历机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gh">
      <meta itemprop="description" content="gratitude and love">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/27/08-HashMap和LinkedHashMap遍历机制/" class="post-title-link" itemprop="url">08-HashMap和LinkedHashMap遍历机制</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-27 16:56:48" itemprop="dateCreated datePublished" datetime="2019-03-27T16:56:48+08:00">2019-03-27</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">2.6k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">2 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇我们着重看下<code>HashMap</code>和<code>LinkedHashMap</code>遍历方式,。</p>
<h2 id="对HashMap和LinkedHashMap遍历的几种方法"><a href="#对HashMap和LinkedHashMap遍历的几种方法" class="headerlink" title="对HashMap和LinkedHashMap遍历的几种方法"></a><font color="#8B475D">对HashMap和LinkedHashMap遍历的几种方法</font></h2><p>这里以<code>HashMap</code>为例，<code>LinkedHashMap</code>一样的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line">    System.out.println(<span class="string">"key="</span> + next.getKey() + <span class="string">" value="</span> + next.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    String key = iterator.next();</span><br><span class="line">    System.out.println(<span class="string">"key="</span> + key + <span class="string">" value="</span> + map.get(key));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key,value)-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"key="</span> + key + <span class="string">" value="</span> + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>强烈建议使用第一种 EntrySet 进行遍历。</strong> 因为第一种可以直接把<code>key</code>和<code>value</code>直接取出，第二种还得通过<code>key</code>重新调用<code>get</code>方法获取<code>value</code>,效率较低, 第三种需要<code>JDK1.8</code>以上，通过外层遍历 <code>table</code>，内层遍历链表或红黑树。</p>
<p>我们知道，<code>HashMap</code>的输出顺序与元素的输入顺序无关，<code>LinkedHashMap</code>可以按照输入顺序输出，也可以根据读取元素的顺序输出。这一现象，已经在上一篇中展示出来了。</p>
<h2 id="HashMap的遍历机制"><a href="#HashMap的遍历机制" class="headerlink" title="HashMap的遍历机制"></a><font color="#8B475D">HashMap的遍历机制</font></h2><p><code>HashMap</code> 提供了两个遍历访问其内部元素<code>Entry&lt;k,v&gt;</code>的接口：</p>
<ul>
<li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()-------&gt;</code>返回此映射所包含的映射关系的 <code>Set</code> 视图。</li>
<li><code>Set&lt;K&gt; keySet()--------&gt;</code>返回此映射中所包含的键的 Set 视图。</li>
</ul>
<blockquote>
<p>实际上，第二个接口表示的<code>Key</code>的顺序，和第一个接口返回的<code>Entry</code>顺序是对应的，也就是说：这两种接口对<code>HashMap</code>的元素遍历的顺序相相同的。 那么，<code>HashMap</code>遍历内部<code>Entry&lt;K,V&gt;</code> 的顺序是什么呢？ 搞清楚这个问题，先要知道其内部结构是怎样的。</p>
</blockquote>
<p><code>HashMap</code>在存储<code>Entry</code>对象的时候，是根据<code>Key</code>的<code>hash</code>值判定存储到<code>Entry[] table</code>数组的哪一个索引值表示的链表上。</p>
<p>对<code>HashMap</code>遍历<code>Entry</code>对象的顺序和<code>Entry</code>对象的存储顺序之间没有任何关系。</p>
<p><strong><code>HashMap</code>散列图、<code>Hashtable</code>散列表是按“有利于随机查找的散列(<code>hash</code>)的顺序”。并非按输入顺序。遍历时只能全部输出，而没有顺序。甚至可以<code>rehash()</code>重新散列，来获得更利于随机存取的内部顺序。</strong></p>
<p>所以对<code>HashMap</code>的遍历，由内部的机制决定的，这个机制是只考虑利于快速存取，不考虑输入等顺序。</p>
<h2 id="LinkedHashMap-的遍历机制"><a href="#LinkedHashMap-的遍历机制" class="headerlink" title="LinkedHashMap 的遍历机制"></a><font color="#8B475D">LinkedHashMap 的遍历机制</font></h2><p><code>LinkedHashMap</code> 是<code>HashMap</code>的子类，它可以实现对容器内<code>Entry</code>的存储顺序和对<code>Entry</code>的遍历顺序保持一致。</p>
<p>为了实现这个功能，<code>LinkedHashMap</code>内部使用了一个<code>Entry</code>类型的双向链表，用这个双向链表记录<code>Entry</code>的存储顺序。当需要对该<code>Map</code>进行遍历的时候，实际上是遍历的是这个双向链表。</p>
<p><code>LinkedHashMap</code>内部使用的<code>LinkedHashMap.Entry</code>类继承自<code>Map.Entry</code>类，在其基础上增加了<code>LinkedHashMap.Entry</code>类型的两个字段，用来引用该<code>Entry</code>在双向链表中的前面的<code>Entry</code>对象和后面的<code>Entry</code>对象。</p>
<p>它的内部会在<code>Map.Entry</code>类的基础上，增加两个<code>Entry</code>类型的引用：<code>before</code>，<code>after</code>。<code>LinkedHashMap</code>使用一个双向连表，将其内部所有的<code>Entry</code>串起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap linkedHashMap = <span class="keyword">new</span> LinkedHashMap();  </span><br><span class="line">linkedHashMap.put(<span class="string">"name"</span>,<span class="string">"louis"</span>);  </span><br><span class="line">linkedHashMap.put(<span class="string">"age"</span>,<span class="string">"24"</span>);  </span><br><span class="line">linkedHashMap.put(<span class="string">"sex"</span>,<span class="string">"male"</span>);</span><br></pre></td></tr></table></figure>

<p>对<code>LinkedHashMap</code>进行遍历的策略：</p>
<p><strong>从 <code>header.after</code> 指向的<code>Entry</code>对象开始，然后一直沿着此链表遍历下去，直到某个<code>entry.after == header</code> 为止，完成遍历。</strong></p>
<p>根据<code>Entry&lt;K,V&gt;</code>插入<code>LinkedHashMap</code>的顺序进行遍历的方式叫做：按插入顺序遍历。</p>
<p>另外，<code>LinkedHashMap</code>还支持一种遍历顺序，叫做：<code>Get</code>读取顺序。</p>
<p>如果<code>LinkedHashMap</code>的这个<code>Get</code>读取遍历顺序开启，那么，当我们在<code>LinkedHashMap</code>上调用<code>get(key)</code> 方法时，会导致内部<code>key</code>对应的<code>Entry</code>在双向链表中的位置移动到双向链表的最后。</p>
<h2 id="遍历机制的总结"><a href="#遍历机制的总结" class="headerlink" title="遍历机制的总结"></a><font color="#8B475D">遍历机制的总结</font></h2><ul>
<li><code>HashMap</code>对元素的遍历顺序跟<code>Entry</code>插入的顺序无关，而<code>LinkedHashMap</code>对元素的遍历顺序可以跟<code>Entry&lt;K,V&gt;</code>插入的顺序保持一致：从双向。</li>
<li>当<code>LinkedHashMap</code>处于<code>Get</code>获取顺序遍历模式下，当执行<code>get()</code> 操作时，会将对应的<code>Entry&lt;k,v&gt;</code>移到遍历的最后位置。</li>
<li><code>LinkedHashMap</code>处于按插入顺序遍历的模式下，如果新插入的<code>&lt;key,value&gt;</code> 对应的<code>key</code>已经存在，对应的<code>Entry</code>在遍历顺序中的位置并不会改变。</li>
<li>除了遍历顺序外，其他特性<code>HashMap</code>和<code>LinkedHashMap</code>基本相同。</li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/24/07-LinkedHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gh">
      <meta itemprop="description" content="gratitude and love">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/24/07-LinkedHashMap/" class="post-title-link" itemprop="url">07-LinkedHashMap</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-24 08:22:48" itemprop="dateCreated datePublished" datetime="2019-03-24T08:22:48+08:00">2019-03-24</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">12k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">11 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>大多少情况下，存储键值对的数据都可以用<code>HashMap</code>,但是它有两个缺点，第一是线程不安全的，而且迭代顺序是无序的，所以我们期待能有解决问题的方法，对于无序的排列我们用 <code>LinkedHashMap</code>来解决。至于线程安全，在后面会讲到。</p>
<p>顾名思义<code>LinkedHashMap</code>是基于双向循环链表构成的，而且它继承自<code>HashMap</code>。</p>
<p><code>LinkedHashMap</code>的排序方式有两种：</p>
<ul>
<li>根据写入的顺序排序。</li>
<li>根据访问的速度排序。</li>
</ul>
<p>其中根据访问顺序排序时，每次 <code>get</code> 都会将访问的值移动到链表末尾，这样重复操作就能得到一个按照访问顺序排序的链表。</p>
<h2 id="LinkedHashMap数据结构"><a href="#LinkedHashMap数据结构" class="headerlink" title="LinkedHashMap数据结构"></a><font color="#8B475D">LinkedHashMap数据结构</font></h2><p><img src="http://blog-picture-g.test.upcdn.net/collection/collection6-1.jpg" alt="image"></p>
<p><code>LinkedHashMap</code>是通过哈希表和双向循环链表实现的，它通过维护一个双向循环链表来保证对哈希表迭代时的有序性，而这个有序是指键值对插入的顺序。</p>
<p>我们可以看出，遍历所有元素只需要从<code>header</code>开始遍历即可，一直遍历到下一个元素是<code>header</code>结束。</p>
<p>另外，当向哈希表中重复插入某个键的时候，不会影响到原来的有序性。也就是说，假设你插入的键的顺序为1、2、3、4，后来再次插入2，迭代时的顺序还是1、2、3、4，而不会因为后来插入的2变成1、3、4、2。（但其实我们可以改变它的规则，使它变成1、3、4、2）</p>
<p><code>LinkedHashMap</code>的实现主要分两部分，一部分是哈希表，另外一部分是链表。哈希表(<code>HashMap</code>中的桶)部分继承了<code>HashMap</code>，拥有了<code>HashMap</code>那一套高效的操作，所以我们要看的就是LinkedHashMap中链表的部分，了解它是如何来维护有序性的。</p>
<h2 id="小栗子"><a href="#小栗子" class="headerlink" title="小栗子"></a><font color="#8B475D">小栗子</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinedListHashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HashMap插入数据，遍历无序输出</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        System.out.println(<span class="string">"-----------HashMap插入数据-----------"</span>);</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"apple"</span>, <span class="string">"a"</span>);</span><br><span class="line">        map.put(<span class="string">"watermelon"</span>, <span class="string">"b"</span>);</span><br><span class="line">        map.put(<span class="string">"banana"</span>, <span class="string">"c"</span>);</span><br><span class="line">        map.put(<span class="string">"peach"</span>, <span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Map.Entry entry = (Map.Entry) iterator.next();</span><br><span class="line">            System.out.println(entry.getKey()+<span class="string">"="</span>+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * LinkedHashMap插入数据，遍历，默认以插入顺序为序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------LinkedHashMap插入数据,按照插入顺序进行排序--------"</span>);</span><br><span class="line">        Map&lt;String,String&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        linkedHashMap.put(<span class="string">"apple"</span>, <span class="string">"a"</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">"watermelon"</span>, <span class="string">"b"</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">"banana"</span>, <span class="string">"c"</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">"peach"</span>, <span class="string">"d"</span>);</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator1 = linkedHashMap.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator1.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator1.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * LinkedHashMap插入数据，设置accessOrder=true实现使得其遍历顺序按照访问的顺序输出，这里先用get方法来演示</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"----------LinkedHashMap插入数据,accessOrder=true:按照访问顺序进行排序--------"</span>);</span><br><span class="line">        Map&lt;String, String&gt; linkedHashMap2 = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">16</span>,<span class="number">0.75f</span>,<span class="keyword">true</span>);</span><br><span class="line">        linkedHashMap2.put(<span class="string">"apple"</span>, <span class="string">"aa"</span>);</span><br><span class="line">        linkedHashMap2.put(<span class="string">"watermelon"</span>, <span class="string">"bb"</span>);</span><br><span class="line">        linkedHashMap2.put(<span class="string">"banana"</span>, <span class="string">"cc"</span>);</span><br><span class="line">        linkedHashMap2.put(<span class="string">"peach"</span>, <span class="string">"dd"</span>);</span><br><span class="line"></span><br><span class="line">        linkedHashMap2.get(<span class="string">"banana"</span>);<span class="comment">//banana移动到了内部的链表末尾</span></span><br><span class="line">        linkedHashMap2.get(<span class="string">"apple"</span>);<span class="comment">//apple移动到了内部的链表末尾</span></span><br><span class="line"></span><br><span class="line">        Iterator iter2 = linkedHashMap2.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter2.hasNext()) &#123;</span><br><span class="line">            Map.Entry entry = (Map.Entry) iter2.next();</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * LinkedHashMap的put方法在accessOrder=true的情况下</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">        linkedHashMap2.put(<span class="string">"watermelon"</span>, <span class="string">"bb"</span>);<span class="comment">//watermelon移动到了内部的链表末尾</span></span><br><span class="line">        linkedHashMap2.put(<span class="string">"stawbarrey"</span>, <span class="string">"ee"</span>);<span class="comment">//末尾插入新元素stawbarrey</span></span><br><span class="line">        linkedHashMap2.put(<span class="keyword">null</span>, <span class="keyword">null</span>);<span class="comment">//插入新的节点 null</span></span><br><span class="line">        Iterator iter3 = linkedHashMap2.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter3.hasNext()) &#123;</span><br><span class="line">            Map.Entry entry = (Map.Entry) iter3.next();</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">----------HashMap插入数据--------</span><br><span class="line">banana=c</span><br><span class="line">apple=a</span><br><span class="line">peach=d</span><br><span class="line">watermelon=b</span><br><span class="line">----------LinkedHashMap插入数据,按照插入顺序进行排序--------</span><br><span class="line">apple=a</span><br><span class="line">watermelon=b</span><br><span class="line">banana=c</span><br><span class="line">peach=d</span><br><span class="line">----------LinkedHashMap插入数据,按照访问顺序进行排序--------</span><br><span class="line">watermelon=bb</span><br><span class="line">peach=dd</span><br><span class="line">banana=cc<span class="comment">//banana到了末尾</span></span><br><span class="line">apple=aa<span class="comment">//apple到了末尾</span></span><br><span class="line">-----------</span><br><span class="line">peach=dd</span><br><span class="line">banana=cc</span><br><span class="line">apple=aa</span><br><span class="line">watermelon=bb<span class="comment">//watermelon到了链表末尾</span></span><br><span class="line">stawbarrey=ee<span class="comment">//新插入的放在末尾</span></span><br><span class="line"><span class="keyword">null</span>=<span class="keyword">null</span><span class="comment">//新插入的放在末尾</span></span><br></pre></td></tr></table></figure>

<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a><font color="#8B475D">属性</font></h2><p><code>LinkedHashMap</code>可以认为是<code>HashMap+LinkedList</code>，即它既使用<code>HashMap</code>操作数据结构，又使用<code>LinkedList</code>维护插入元素的先后顺序。</p>
<h5 id="继承关系"><a href="#继承关系" class="headerlink" title="#继承关系"></a>#<font color="#367bdd">继承关系</font></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>LinkedHashMap</code>是<code>HashMap</code>的子类，自然<code>LinkedHashMap</code>也就继承了<code>HashMap</code>中所有非<code>private</code>的方法。所以它已经从 <code>HashMap</code>那里继承了与哈希表相关的操作了，那么在<code>LinkedHashMap</code>中，它可以专注于链表实现的那部分，所以与链表实现相关的属性如下。</p>
<h5 id="节点属性"><a href="#节点属性" class="headerlink" title="#节点属性"></a>#<font color="#367bdd">节点属性</font></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedHashMap的链表节点继承了HashMap的节点，而且每个节点都包含了前指针和后指针，所以这里可以看出它是一个双向链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾指针</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认为false。当为true时，表示链表中键值对的顺序与每个键的插入顺序一致，也就是说重复插入键，也会更新顺序</span></span><br><span class="line"><span class="comment">//简单来说，为false时，就是上面所指的1、2、3、4的情况；为true时，就是1、3、4、2的情况</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><font color="#8B475D">构造方法</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是调用的 <code>HashMap</code> 的构造方法:</p>
<p><code>HashMap</code> 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    <span class="comment">//HashMap 只是定义了改方法，具体实现交给了 LinkedHashMap</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到里面有一个空的 <code>init()</code>，具体是由 <code>LinkedHashMap</code> 来实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    header = <span class="keyword">new</span> Entry&lt;&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    header.before = header.after = header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实也就是对<code>header</code>进行了初始化。</p>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a><font color="#8B475D">添加元素</font></h2><p><img src="http://blog-picture-g.test.upcdn.net/collection/collection6-2.jpg" alt="image"></p>
<p><code>LinkedHashMap</code>并没有重写任何put方法。但是其重写了构建新节点的<code>newNode()</code>方法.</p>
<p><code>newNode()</code> 会在<code>HashMap</code>的<code>putVal()</code> 方法里被调用，<code>putVal()</code> 方法会在批量插入数据<code>putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)</code> 或者插入单个数据<code>public V put(K key, V value)</code>时被调用。</p>
<p><code>LinkedHashMap</code>重写了<code>newNode()</code>,在每次构建新节点时，通过<code>linkNodeLast(p)</code>;将新节点链接在内部双向链表的尾部。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在构建新节点时，构建的是`LinkedHashMap.Entry` 不再是`Node`.</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将新增的节点，连接在链表的尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="comment">//集合之前是空的</span></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//将新节点连接在链表的尾部</span></span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及<code>HashMap</code>专门预留给<code>LinkedHashMap</code>的<code>afterNodeAccess()</code> 、<code>afterNodeInsertion()</code> 、<code>afterNodeRemoval()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>如果你没有注意到注释的解释的话，你可能会很奇怪为什么会有三个空方法，而且有不少地方还调用过它们。其实这三个方法表示的是在访问、插入、删除某个节点之后，进行一些处理，它们在<code>LinkedHashMap</code>有各自的实现。<code>LinkedHashMap</code>正是通过重写这三个方法来保证链表的插入、删除的有序性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调函数，新节点插入之后回调,判断是否需要删除最老插入的节点。</span></span><br><span class="line"><span class="comment">//如果实现LruCache会用到这个方法。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">//LinkedHashMap 默认返回false 则不删除节点</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//LinkedHashMap 默认返回false 则不删除节点。 </span></span><br><span class="line"><span class="comment">//返回true 代表要删除最早的节点。</span></span><br><span class="line"><span class="comment">//通常构建一个LruCache会在达到Cache的上限是返回true</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a><font color="#8B475D">删除元素</font></h2><p><code>LinkedHashMap</code>也没有重写<code>remove()</code> 方法，因为它的删除逻辑和<code>HashMap</code>并无区别。<br>但它重写了<code>afterNodeRemoval()</code> 这个回调方法。该方法会在<code>Node&lt;K,V&gt; removeNode(int hash, Object key, Object value</code>,<br><code>boolean matchValue, boolean movable)</code> 方法中回调，<code>removeNode()</code> 会在所有涉及到删除节点的方法中被调用，上文分析过，是删除节点操作的真正执行者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在删除节点e时，同步将e从双向链表上删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">//待删除节点 p 的前置后置节点都置空</span></span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//如果前置节点是null，则现在的头结点应该是后置节点a</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//否则将前置节点b的后置节点指向a</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="comment">//同理如果后置节点时null ，则尾节点应是b</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//否则更新后置节点a的前置节点为b</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询元素"><a href="#查询元素" class="headerlink" title="查询元素"></a><font color="#8B475D">查询元素</font></h2><p><code>LinkedHashMap</code>重写了<code>get()</code>和<code>getOrDefault()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">return</span> defaultValue;</span><br><span class="line">   <span class="keyword">if</span> (accessOrder)</span><br><span class="line">       afterNodeAccess(e);</span><br><span class="line">   <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比<code>HashMap</code>中的实现,<code>LinkedHashMap</code>只是增加了在成员变量(构造函数时赋值)<code>accessOrder</code>为<code>true</code>的情况下，要去回调<code>void afterNodeAccess(Node&lt;K,V&gt; e)</code> 函数。</p>
<p>在<code>afterNodeAccess()</code> 函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last;<span class="comment">//原来为节点</span></span><br><span class="line">        <span class="comment">//如果accessOrder节点为true并且为节点不等于e</span></span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123; </span><br><span class="line">            <span class="comment">//将p节点置为e节点，并记录e节点的前后节点</span></span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">            <span class="comment">//p节点现在是尾节点，后置节点设置为空</span></span><br><span class="line">            p.after = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//判断是否为头节点</span></span><br><span class="line">            <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">                head = a;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//否则更新p的前直接点b的后置节点为 a</span></span><br><span class="line">                b.after = a;</span><br><span class="line">            <span class="comment">//如果p的后置节点不是null，则更新后置节点a的前置节点为b</span></span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//如果原本p的后置节点是null，则p就是尾节点。 此时 更新last的引用为 p的前置节点b</span></span><br><span class="line">                last = b;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="keyword">null</span>)<span class="comment">//原本尾节点是null  则，链表中就一个节点</span></span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//否则 更新 当前节点p的前置节点为 原尾节点last， last的后置节点是p</span></span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//尾节点的引用赋值成p</span></span><br><span class="line">            tail = p;</span><br><span class="line">            <span class="comment">//修改modCount。</span></span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，<strong><code>afterNodeAccess()</code> 函数中，会修改<code>modCount</code>,因此当你正在<code>accessOrder=true</code>的模式下,迭代<code>LinkedHashMap</code>时，如果同时查询访问数据，也会导致<code>fail-fast</code>，因为迭代的顺序已经改变。</strong></p>
<h2 id="判断元素是否存在"><a href="#判断元素是否存在" class="headerlink" title="判断元素是否存在"></a><font color="#8B475D">判断元素是否存在</font></h2><p>它重写了该方法，相比<code>HashMap</code>的实现，更为高效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历一遍链表，去比较有没有value相等的节点，并返回</span></span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">        V v = e.value;</span><br><span class="line">        <span class="keyword">if</span> (v == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比<code>HashMap</code>，是用两个<code>for</code>循环遍历，相对低效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="替换某个元素"><a href="#替换某个元素" class="headerlink" title="替换某个元素"></a><font color="#8B475D">替换某个元素</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用dst替换src</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferLinks</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; src,</span></span></span><br><span class="line"><span class="function"><span class="params">                               LinkedHashMap.Entry&lt;K,V&gt; dst)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; b = dst.before = src.before;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; a = dst.after = src.after;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = dst;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = dst;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = dst;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://blog-picture-g.test.upcdn.net/collection/collection6-3.png" alt="image"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font color="#8B475D">总结</font></h2><p><code>LinkedHashMap</code>相对于<code>HashMap</code>的源码比，是很简单的。因为大树底下好乘凉。它继承了<code>HashMap</code>，仅重写了几个方法，以改变它迭代遍历时的顺序。这也是其与<code>HashMap</code>相比最大的不同。</p>
<p>在每次插入数据，或者访问、修改数据时，会增加节点、或调整链表的节点顺序。以决定迭代时输出的顺序。</p>
<ul>
<li><code>accessOrder</code>默认是<code>false</code>，则迭代时输出的顺序是插入节点的顺序。若为<code>true</code>，则输出的顺序是按照访问节点的顺序。为<code>true</code>时，可以在这基础之上构建一个<code>LruCache</code>。</li>
<li><code>LinkedHashMap</code>并没有重写任何<code>put</code>方法。但是其重写了构建新节点的<code>newNode()</code>方法.在每次构建新节点时，将新节点链接在内部双向链表的尾部</li>
<li><code>accessOrder=true</code>的模式下,在<code>afterNodeAccess()</code>函数中，会将当前被访问到的节点<code>e</code>，移动至内部的双向链表的尾部。值得注意的是，<code>afterNodeAccess()</code>函数中，会修改<code>modCount</code>,因此当你正在<code>accessOrder=true</code>的模式下,迭代<code>LinkedHashMap</code>时，如果同时查询访问数据，也会导致<code>fail-fast</code>，因为迭代的顺序已经改变。</li>
<li><code>nextNode()</code> 就是迭代器里的<code>next()</code>方法 。该方法的实现可以看出，迭代<code>LinkedHashMap</code>，就是从内部维护的双链表的表头开始循环输出。</li>
<li>而双链表节点的顺序在<code>LinkedHashMap</code>的增、删、改、查时都会更新。以满足按照插入顺序输出，还是访问顺序输出。</li>
<li>它与<code>HashMap</code>比，还有一个小小的优化，重写了<code>containsValue()</code>方法，直接遍历内部链表去比对<code>value</code>值是否相等。</li>
</ul>
<p>整理自：</p>
<ul>
<li><a href="http://blog.csdn.net/zxt0601/article/details/77429150" target="_blank" rel="noopener">面试必备：LinkedHashMap源码解析（JDK8）</a>  </li>
<li><a href="http://wiki.jikexueyuan.com/project/java-collection/linkedhashmap.html" target="_blank" rel="noopener">LinkedHashMap 的实现原理</a> </li>
<li><a href="http://blog.csdn.net/u013124587/article/details/52659741" target="_blank" rel="noopener">Java8 - LinkedHashMap源码</a> </li>
<li><a href="http://www.cnblogs.com/leesf456/p/5248868.html" target="_blank" rel="noopener">【集合框架】JDK1.8源码分析之LinkedHashMap（二）</a>  </li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/23/06-HashSet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gh">
      <meta itemprop="description" content="gratitude and love">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/23/06-HashSet/" class="post-title-link" itemprop="url">06-HashSet</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-23 12:22:48" itemprop="dateCreated datePublished" datetime="2019-03-23T12:22:48+08:00">2019-03-23</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">1.1k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">1 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>HashSet</code> 是一个不允许存储重复元素的集合，它是基于 <code>HashMap</code> 实现的， <code>HashSet</code> 底层使用 <code>HashMap</code> 来保存所有元素，因此 <code>HashSet</code> 的实现比较简单，相关 <code>HashSet</code> 的操作，基本上都是直接调用底层 <code>HashMap</code> 的相关方法来完成。所以只要理解了 <code>HashMap</code>，<code>HashSet</code> 就水到渠成了。</p>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a><font color="#8B475D">成员变量</font></h2><p>首先了解下<code>HashSet</code>的成员变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<p>发现主要就两个变量:</p>
<ul>
<li><code>map</code> ：用于存放最终数据的。</li>
<li><code>PRESENT</code> ：是所有写入<code>map</code>的<code>value</code>值。</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><font color="#8B475D">构造方法</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数很简单，直接利用了<code>HashMap</code>初始化了map。</p>
<h2 id="add"><a href="#add" class="headerlink" title="add"></a><font color="#8B475D">add</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较关键的就是这个 <code>add()</code> 方法。 可以看出它是将存放的对象当做了 <code>HashMap</code> 的健，<code>value</code> 都是相同的 <code>PRESENT</code> 。由于 <code>HashMap</code> 的 <code>key</code> 是不能重复的，所以每当有重复的值写入到 <code>HashSet</code> 时，<code>value</code> 会被覆盖，但 <code>key</code> 不会受到影响，这样就保证了 <code>HashSet</code> 中只能存放不重复的元素。</p>
<p>该方法如果添加的是在 <code>HashSet</code> 中不存在的，则返回 <code>true</code>；如果添加的元素已经存在，返回 <code>false</code>。其原因在于我们之前提到的关于 <code>HashMap</code> 的 <code>put</code> 方法。该方法在添加 <code>key</code>不重复的键值对的时候，会返回 <code>null</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><font color="#8B475D">总结</font></h2><p><code>HashSet</code>的原理比较简单，几乎全部借助于 <code>HashMap</code>来实现的。</p>
<p>所以 <code>HashMap</code>会出现的问题 <code>HashSet</code> 依然不能避免。</p>
<p><code>hashSet</code>重点和特点都在于前面我们说过的<code>equals</code>和<code>hashcode</code>,保证放入的对象的唯一性。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/30/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><span class="page-number current">31</span><a class="page-number" href="/page/32/">32</a><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/32/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Gh">
            
              <p class="site-author-name" itemprop="name">Gh</p>
              <div class="site-description motion-element" itemprop="description">gratitude and love</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">328</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com" title="GitHub &rarr; https://github.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/yourname" title="Weibo &rarr; https://weibo.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://stackoverflow.com/yourname" title="StackOverflow &rarr; https://stackoverflow.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/" title="blibili &rarr; "><i class="fa fa-fw fa-globe"></i>blibili</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.zykcoderman.xyz/web/index" title="https://www.zykcoderman.xyz/web/index" rel="noopener" target="_blank">章鱼社区</a>
                  </li>
                
              </ul>
            </div>
          

          
        </div>
      </div>

      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gh</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">859k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">13:01</span>
  
</div>








        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  





  
    
    
  
  <script color="0,0,0" opacity="0.5" zindex="-1" count="150" src="/lib/canvas-nest/canvas-nest.min.js"></script>









  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  


  
  
  

  

</body>
</html>
