<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2">



















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/ffavicon32.ico?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon32.ico?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":15,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>



  <meta name="description" content="闲敲棋子落灯花">
<meta property="og:type" content="website">
<meta property="og:title" content="To be or not to be?">
<meta property="og:url" content="http://yoursite.com/page/16/index.html">
<meta property="og:site_name" content="To be or not to be?">
<meta property="og:description" content="闲敲棋子落灯花">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="To be or not to be?">
<meta name="twitter:description" content="闲敲棋子落灯花">



  <link rel="alternate" href="/atom.xml" title="To be or not to be?" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://yoursite.com/page/16/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>To be or not to be?</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">To be or not to be?</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">gaohan的学习小栈</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>about me</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



</div>
    </header>

    
  
  

  

  <a href="https://github.com/gaohanblog/gaohanblog.github.io" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/28/leetCode-52-n皇后问题(位运算)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="96gh'home">
      <meta itemprop="description" content="闲敲棋子落灯花">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/28/leetCode-52-n皇后问题(位运算)/" class="post-title-link" itemprop="url">leetCode-52-n皇后问题(位运算)</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-28 09:23:26" itemprop="dateCreated datePublished" datetime="2019-11-28T09:23:26+08:00">2019-11-28</time>
            </span>
          

          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">1.9k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">2 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给定一个整数 n，返回返回n皇后不同的解决方案的数量。</p>
<blockquote>
<p>示例:</p>
<p>输入: 4</p>
<p>输出: [</p>
<p>[“.Q..”,  // 解法 1</p>
<p>“…Q”,</p>
<p>“Q…”,</p>
<p>“..Q.”],</p>
<p>[“..Q.”,  // 解法 2</p>
<p>“Q…”,</p>
<p>“…Q”,</p>
<p>“.Q..”]</p>
<p>]</p>
<p>解释: 4 皇后问题存在两个不同的解法。</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>51题和52题不同的地方在，一个要求找出所有答案，一个要求找出答案数量。</p>
<p>在52题中，为什么老师会在位运算讲到这个题，n皇后问题有一个特别巧妙的解法，就是用位运算，之前做这个题，在递归的时候判断当前位置是否被前面皇后攻击会有大量的判断，而且这些判断是比较浪费时间的。计算机计算是基于位的运算，位运算执行效率会更高，问题中每个皇后影响的状态，可分为被攻击和不被攻击两种状态，可不可以用位中1和0来表示，然后再通过移位等操作来控制被影响位的状态哪，在cpu中运算单位是以位为单元来操作的，所以通过位运算来做是目前最优的解法了。</p>
<h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row 当前层</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col 被前面皇后影响的列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pie 被前面皇后攻击的从右上到左下的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> na  被前面皇后攻击的从左上到右下的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span> pie,<span class="keyword">int</span> na,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//终止条件 被遍历最后一层 退出得到一种解法</span></span><br><span class="line">        <span class="keyword">if</span>(row &gt;= n)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  1、col，pie，na分别表示当前行被之前皇后攻击的列，撇，纳</span></span><br><span class="line"><span class="comment">         *  2、col | pie | na 表示当前行皇后被攻击位的集合</span></span><br><span class="line"><span class="comment">         *  3、因为bits是32位，n皇后问题著需要用到一个int类型的后n位就可以,所以</span></span><br><span class="line"><span class="comment">         *      ~(col | pie | na) 先把当前被攻击位取反，((1 &lt;&lt; n) - 1)表示当前用到的n</span></span><br><span class="line"><span class="comment">         *      位全都设置位 1 ，然后按位和~(col | pie | na)与运算，得到的结果里面，后n位</span></span><br><span class="line"><span class="comment">         *      是有效位，就是所有的 1 表示没被前面皇后攻击的位。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> bits = (~(col | pie | na)) &amp; ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//遍历所有为1的位</span></span><br><span class="line">        <span class="keyword">while</span>(bits &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//得到最后一位的 1 ，即得到有最后一位可以放的位置</span></span><br><span class="line">            <span class="keyword">int</span> p = bits &amp; -bits;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  得到当前可放位置，继续遍历下一层</span></span><br><span class="line"><span class="comment">             *  row+1 ： 下一层</span></span><br><span class="line"><span class="comment">             *  col | p ： 下一层中被攻击的列</span></span><br><span class="line"><span class="comment">             *  (pie | p ) &lt;&lt; 1 ： 因为被攻击的撇向下走了一层，所以被攻击位 需要左移一位</span></span><br><span class="line"><span class="comment">             *  (na | p ) &gt;&gt; 1 ：  被攻击的纳向下走了一层，所以被攻击位 需要右移一位</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            dfs(row+<span class="number">1</span>,col | p,(pie | p ) &lt;&lt; <span class="number">1</span>,(na | p ) &gt;&gt; <span class="number">1</span> ,n);</span><br><span class="line">            <span class="comment">//去掉当前位的最后一个1，继续遍历当前层是否还有1</span></span><br><span class="line">            bits &amp;= bits - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/27/09-内存分配与回收/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="96gh'home">
      <meta itemprop="description" content="闲敲棋子落灯花">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/27/09-内存分配与回收/" class="post-title-link" itemprop="url">09-内存分配与回收</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-27 13:07:48" itemprop="dateCreated datePublished" datetime="2019-11-27T13:07:48+08:00">2019-11-27</time>
            </span>
          

          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">1.8k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">2 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对内存分配和垃圾回收的细节再次详细说明一下，并且说明一下逃逸分析/栈上分配以及TLAB两种方式的概念和原理。</p>
<h2 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a><font color="#8B475D">对象优先在Eden分配</font></h2><p>前面文章曾介绍HotSpot虚拟机新生代内存布局及算法:</p>
<ul>
<li><p>（1）、将新生代内存分为一块较大的<code>Eden</code>空间和两块较小的<code>Survivor</code>空间；</p>
</li>
<li><p>（2）、每次使用<code>Eden</code>和其中一块<code>Survivor</code>；</p>
</li>
<li><p>（3）、当回收时，将<code>Eden</code>和使用中的<code>Survivor</code>中还存活的对象一次性复制到另外一块<code>Survivor</code>；</p>
</li>
<li><p>（4）、而后清理掉<code>Eden</code>和使用过的<code>Survivor</code>空间；</p>
</li>
<li><p>（5）、后面就使用<code>Eden</code>和复制到的那一块<code>Survivor</code>空间，重复步骤3；</p>
</li>
</ul>
<p>默认<code>Eden：Survivor=8:1</code>，即每次可以使用90%的空间，只有一块<code>Survivor</code>的空间被浪费；</p>
<p>大多数情况下，对象在新生代<code>Eden</code>区中分配；</p>
<p>当<code>Eden</code>区没有足够空间进行分配时，<code>JVM</code>将发起一次<code>Minor GC</code>（新生代GC）；</p>
<p><code>Minor GC</code>时，如果发现存活的对象无法全部放入<code>Survivor</code>空间，只好通过分配担保机制提前转移到老年代。</p>
<h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a><font color="#8B475D">大对象直接进入老年代</font></h2><p>大对象指需要大量连续内存空间的Java对象，如，很长的字符串、数组；</p>
<p>经常出现大对象容易导致内存还有不少空间就提前触发GC,以获取足够的连续空间来存放它们，所以应该尽量避免使用创建大对象；</p>
<p><code>-XX:PretenureSizeThreshold</code>：</p>
<p><strong>可以设置这个阈值，大于这个参数值的对象直接在老年代分配；</strong></p>
<p>默认为0（无效），且只对<code>Serail</code>和<code>ParNew</code>两款收集器有效；</p>
<p>如果需要使用该参数，可考虑<code>ParNew+CMS</code>组合。</p>
<h2 id="可以设置这个阈值，大于这个参数值的对象直接在老年代分配；"><a href="#可以设置这个阈值，大于这个参数值的对象直接在老年代分配；" class="headerlink" title="可以设置这个阈值，大于这个参数值的对象直接在老年代分配；"></a><font color="#8B475D">可以设置这个阈值，大于这个参数值的对象直接在老年代分配；</font></h2><p>JVM给每个对象定义一个对象年龄计数器，其计算流程如下：</p>
<blockquote>
<p><font color="#333">在Eden中分配的对象，经Minor GC后还存活，就复制移动到Survivor区，年龄为1；<br><br><br>而后每经一次Minor GC后还存活，在Survivor区复制移动一次，年龄就增加1岁；<br><br><br>如果年龄达到一定程度，就晋升到老年代中；<br></font></p>
</blockquote>
<p><code>-XX:MaxTenuringThreshold：</code></p>
<p><strong>设置新生代对象晋升老年代的年龄阈值，默认为15；</strong></p>
<h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a><font color="#8B475D">动态对象年龄判定</font></h2><p>JVM为更好适应不同程序，不是永远要求等到<code>MaxTenuringThreshold</code>中设置的年龄；</p>
<p>如果在<code>Survivor</code>空间中相同年龄的所有对象大小总和大于<code>Survivor</code>空间的一半，大于或等于该年龄的对象就可以直接进入老年代。</p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a><font color="#8B475D">空间分配担保</font></h2><p>在前面曾简单介绍过分配担保：</p>
<p>当<code>Survivor</code>空间不够用时，需要依赖其他内存（老年代）进行分配担保（<code>Handle Promotion</code>）；</p>
<p><strong>分配担保的流程如下：</strong></p>
<ul>
<li><p>在发生<code>Minor GC</code>前，JVM先检查老年代最大可用的连续空间是否大于新生所有对象空间；</p>
</li>
<li><p>如果大于，那可以确保<code>Minor GC</code>是安全的；</p>
</li>
<li><p>如果不大于，则JVM查看<code>HandlePromotionFailure</code>值是否允许担保失败；</p>
</li>
<li><p>如果允许，就继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小；</p>
</li>
<li><p>如果大于，将尝试进行一次<code>Minor GC</code>，但这是有风险的；</p>
</li>
<li><p>如果小于或<code>HandlePromotionFailure</code>值不允许冒险，那这些也要改为进行一次<code>Full GC</code>；</p>
</li>
</ul>
<p><strong>尝试<code>Minor GC</code>的风险–担保失败：</strong></p>
<blockquote>
<p><font color="#333">因为尝试<code>Minor</code> GC前面，无法知道存活的对象大小，所以使用历次晋升到老年代对象的平均大小作为经验值；<br><br><br>假如尝试的<code>Minor</code> GC最终存活的对象远远高于经验值的话，会导致担保失败（<code>Handle Promotion Failure</code>）；<br><br><br>失败后只有重新发起一次<code>Full GC</code>，这绕了一个大圈，代价较高；<br></font></p>
</blockquote>
<p><strong>但一般还是要开启<code>HandlePromotionFailure</code>，避免<code>Full GC</code>过于频繁，而且担保失败概率还是比较低的；</strong></p>
<p><code>JDK6-u24</code>后，JVM代码中已经不再使用<code>HandlePromotionFailure</code>参数了；</p>
<p><strong>规则变为：</strong></p>
<p><strong>只要老年代最大可用的连续空间大于新生所有对象空间或历次晋升到老年代对象的平均大小，就会进行Minor GC；否则进行Full GC；</strong></p>
<p><strong>即老年代最大可用的连续空间小于新生所有对象空间时，不再检查<code>HandelPromotionFailure</code>，而直接检查历次晋升到老年代对象的平均大小；</strong></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/27/10-类的初始化过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="96gh'home">
      <meta itemprop="description" content="闲敲棋子落灯花">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/27/10-类的初始化过程/" class="post-title-link" itemprop="url">10-类的初始化过程</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-27 13:07:48" itemprop="dateCreated datePublished" datetime="2019-11-27T13:07:48+08:00">2019-11-27</time>
            </span>
          

          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">8.4k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">8 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>其实在前面的文章中已经说到了类加载机制，但是为了本文的完整性，前面一部分还是重复地放在这里，后面会着重说明初始化过程。</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a><font color="#8B475D">类加载过程</font></h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（<code>Loading</code>）、验证（<code>Verification</code>）、准备(<code>Preparation</code>)、解析(<code>Resolution</code>)、初始化(<code>Initialization</code>)、使用(<code>Using</code>)和卸载(<code>Unloading</code>)7个阶段。其中准备、验证、解析3个部分统称为连接（<code>Linking</code>）。如图所示：</p>
<p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。以下陈述的内容都以HotSpot为基准。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a><font color="#8B475D">加载</font></h2><p><strong>在加载阶段</strong>（可以参考<code>java.lang.ClassLoader</code>的<code>loadClass()</code>方法），虚拟机需要完成以下3件事情：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li>
<li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口；</li>
</ul>
<p>加载阶段和连接阶段（<code>Linking</code>）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a><font color="#8B475D">验证</font></h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p><strong>验证阶段大致会完成4个阶段的检验动作：</strong></p>
<blockquote>
<p><font color="#333">文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</font></p>
</blockquote>
<blockquote>
<p><font color="#333">元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</font></p>
</blockquote>
<blockquote>
<p><font color="#333">字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</font></p>
</blockquote>
<blockquote>
<p><font color="#333">符号引用验证：确保解析动作能正确执行。</font></p>
</blockquote>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a><font color="#8B475D">准备</font></h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被<code>static</code>修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>那变量<code>value</code>在准备阶段过后的初始值为0而不是123.因为这时候尚未开始执行任何java方法，而把<code>value</code>赋值为123的<code>putstatic</code>指令是程序被编译后，存放于类构造器()方法之中，所以把<code>value</code>赋值为123的动作将在初始化阶段才会执行。</p>
<p><strong>至于“特殊情况”是指</strong>：<code>public static final int value=123</code>，即当类字段的字段属性是<code>ConstantValue</code>时，会在准备阶段初始化为指定的值，所以标注为<code>final</code>之后，<code>value</code>的值在准备阶段初始化为123而非0.</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a><font color="#8B475D">解析</font></h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><font color="#8B475D">初始化</font></h2><p>类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，或者说：初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程.</p>
<p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块<code>static{}</code>中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的， <strong>静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</strong> 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        System.out.println(i);<span class="comment">//这句编译器会报错：Cannot reference a field before it is defined（非法向前应用）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么去掉报错的那句，改成下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//      System.out.println(i);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果是什么呢？当然是1啦~在准备阶段我们知道i=0，然后类初始化阶段按照顺序执行，首先执行<code>static</code>块中的<code>i=0</code>,接着执行<code>static</code>赋值操作<code>i=1</code>,最后在<code>main</code>方法中获取i的值为1。</p>
<p><code>&lt;clinit&gt;()</code>方法与实例构造器<code>&lt;init&gt;()</code>方法不同，它不需要显示地调用父类构造器，虚拟机会保证在子类<code>&lt;cinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕.</p>
<p><strong>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</clinit></strong></p>
<p><code>&lt;clinit&gt;()</code>方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产<code>&lt;clinit&gt;()</code>方法。</p>
<p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的。</p>
<p>虚拟机规范严格规定了<strong>有且只有5中情况</strong>（jdk1.7）必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<blockquote>
<p><font color="#333">1.遇到 <code>new</code> , <code>getstatic</code> , <code>putstatic</code> , <code>invokestatic</code> 这些字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：<strong>①使用new关键字实例化对象的时候、②读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及③调用一个类的静态方法的时候。</strong></font></p>
</blockquote>
<blockquote>
<p><font color="#333">2.使用<code>java.lang.reflect</code>包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</font></p>
</blockquote>
<blockquote>
<p><font color="#333">3.当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</font></p>
</blockquote>
<blockquote>
<p><font color="#333">4.当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</font></p>
</blockquote>
<p>下面说明三种被动引用(除了上面提到的五种情况外，所有引用类的方法都不会触发初始化，成为被动引用)。</p>
<p><strong>第一种：通过子类引用父类的静态字段，不会导致子类初始化。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"superclass static init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass static init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">superclass static init</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>说明：对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p>
<p><strong>第二种：通过数组定义来引用类，不会触发此类的初始化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter12;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SuperClass复用上面个代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：（无）</p>
<p>说明：从结果来看，显然没有触发类<code>chapter12.SuperClass</code>的初始化阶段，但是这段代码触发了另一个名叫 <code>&quot;[Lchapter12.SuperClass&quot;</code>的类的初始化阶段。这显然不是一个合法的类名称，他是由虚拟机自动生成的、直接继承于<code>java.lang.Object</code>的子类，创建动作由字节码制定<code>newarray</code>触发。</p>
<p>这个类代表了一个元素类型为<code>chapter12.SuperClass</code>的一维数组，数组中应有的属性和方法(用于可直接使用的只有被修饰为<code>public</code>的<code>length</code>属性和<code>clone()</code>方法)都实现在这个类里。Java语言中对数组的访问比C/C++相对安全是因为这个类封装了数组元素的访问方法，而C/C ++ 直接翻译为对数组指针的移动。</p>
<p><strong>第三种：常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"ConstClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<code>hello world</code>‘</p>
<p>说明：上述代码虽然在java源码中引用了<code>ConstClass</code>类中的常量<code>hello world</code>，但是其实在编译阶段通过常量传播优化，已经将此常量值<code>hello world</code>存储到了<code>NotInitialization</code>的常量池中，以后<code>NotInitialization</code>对常量<code>ConstClass.HELLOWORLD</code>的引用实际上都被转化为<code>NotInitialization</code>对自身常量池的引用了。</p>
<h2 id="接口的加载"><a href="#接口的加载" class="headerlink" title="接口的加载"></a><font color="#8B475D">接口的加载</font></h2><p>接口的加载过程与类加载过程有一些不同，针对接口需要做一些特殊说明：</p>
<p>接口也有初始化过程，而接口中不能使用<code>static{}</code>语句块，但编译器仍然会为接口生成<code>&quot;&lt;clinit()&gt;&quot;</code>类构造器，用于初始化接口中所定义的成员变量。</p>
<p>接口与类真正所区别的是前面讲述的5种“有且仅有”情况的第三种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个借口在初始化时，并不要求其父接口全部都已经完成了初始化，只有在真正用到父接口时（如引用接口中定义的常量）才会初始化。</p>
<h2 id="例子巩固"><a href="#例子巩固" class="headerlink" title="例子巩固"></a><font color="#8B475D">例子巩固</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SSClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SSClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> <span class="keyword">extends</span> <span class="title">SSClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init SuperClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init SubClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SSClass</span><br><span class="line">SuperClass init!</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>说明：对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p>
<h2 id="总结java执行顺序"><a href="#总结java执行顺序" class="headerlink" title="总结java执行顺序"></a><font color="#8B475D">总结java执行顺序</font></h2><p>举例立刻明白：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Children</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Children构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Children普通代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Children静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Children children = <span class="keyword">new</span> Children();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent普通代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Parent静态代码块</span><br><span class="line">Children静态代码块</span><br><span class="line">Parent普通代码块</span><br><span class="line">Parent构造函数</span><br><span class="line">Children普通代码块</span><br><span class="line">Children构造函数</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">父类静态块</span><br><span class="line">自身静态块</span><br><span class="line">父类块</span><br><span class="line">父类构造器</span><br><span class="line">自身块</span><br><span class="line">自身构造器</span><br></pre></td></tr></table></figure>

<h2 id="总结java赋值顺序"><a href="#总结java赋值顺序" class="headerlink" title="总结java赋值顺序"></a><font color="#8B475D">总结java赋值顺序</font></h2><p>举例立刻明白：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String flag = <span class="string">"父类成员变量赋值"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"父类构造器---&gt;"</span> + flag);</span><br><span class="line">        flag = <span class="string">"父类构造器赋值"</span>;</span><br><span class="line">        System.out.println(<span class="string">"父类构造器---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"父类代码块---&gt;"</span> + flag);</span><br><span class="line">        flag = <span class="string">"父类代码块赋值"</span>;</span><br><span class="line">        System.out.println(<span class="string">"父类代码块---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String flag = <span class="string">"成员变量赋值"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Children</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"子类构造器---&gt;"</span> + flag);</span><br><span class="line">        flag = <span class="string">"子类构造器赋值"</span>;</span><br><span class="line">        System.out.println(<span class="string">"子类构造器---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"子类代码快---&gt;"</span> + flag);</span><br><span class="line">        flag = <span class="string">"子类代码块赋值"</span>;</span><br><span class="line">        System.out.println(<span class="string">"子类代码块---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"子类方法---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Children children = <span class="keyword">new</span> Children();</span><br><span class="line">        children.setFlag();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">父类代码块---&gt;父类成员变量赋值</span><br><span class="line">父类代码块---&gt;父类代码块赋值</span><br><span class="line"></span><br><span class="line">父类构造器---&gt;父类代码块赋值</span><br><span class="line">父类构造器---&gt;父类构造器赋值</span><br><span class="line"></span><br><span class="line">子类代码快---&gt;成员变量赋值</span><br><span class="line">子类代码块---&gt;子类代码块赋值</span><br><span class="line"></span><br><span class="line">子类构造器---&gt;子类代码块赋值</span><br><span class="line">子类构造器---&gt;子类构造器赋值</span><br><span class="line"></span><br><span class="line">子类方法---&gt;子类构造器赋值</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">父类的静态变量赋值</span><br><span class="line">自身的静态变量赋值</span><br><span class="line"></span><br><span class="line">父类成员变量赋值</span><br><span class="line">父类块赋值</span><br><span class="line">父类构造器赋值</span><br><span class="line"></span><br><span class="line">自身成员变量赋值</span><br><span class="line">自身块赋值</span><br><span class="line">自身构造器赋值</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/27/leetCode-122-有效的字母异位词/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="96gh'home">
      <meta itemprop="description" content="闲敲棋子落灯花">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/27/leetCode-122-有效的字母异位词/" class="post-title-link" itemprop="url">leetCode-122-有效的字母异位词</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-27 09:23:26" itemprop="dateCreated datePublished" datetime="2019-11-27T09:23:26+08:00">2019-11-27</time>
            </span>
          

          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">1.4k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">1 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: s = “anagram”, t = “nagaram”</p>
<p>输出: true<br>示例 2:</p>
<p>输入: s = “rat”, t = “car”</p>
<p>输出: false</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>用HashMap来做最简单就是先把第一个字符串所有字符都存起来，遍历第二个字符串挨个剔除有的字符。</p>
<p>还有一个利用equals特性，先把所有字符排序，排序好后直接用String的equals方法判定。</p>
<h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] chars1 = t.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(aChar))&#123;</span><br><span class="line">                map.replace(aChar,map.get(aChar) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(aChar,<span class="number">1</span>);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars1) &#123;</span><br><span class="line">            <span class="comment">//字符出现一次直接删除</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c) &amp;&amp; map.get(c) == <span class="number">1</span>)&#123;</span><br><span class="line">                map.remove(c);</span><br><span class="line">            <span class="comment">//出现两次取value-1</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">                map.replace(c,map.get(c) - <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram_1</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] chars1 = t.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        Arrays.sort(chars1);</span><br><span class="line">        <span class="comment">//这里把排序后的字符串用String的equals判断也可以</span></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(chars).equals(String.valueOf(chars1));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/leetCode-242-有效的字母异位词/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="96gh'home">
      <meta itemprop="description" content="闲敲棋子落灯花">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/26/leetCode-242-有效的字母异位词/" class="post-title-link" itemprop="url">leetCode-242-有效的字母异位词</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-26 08:21:26" itemprop="dateCreated datePublished" datetime="2019-11-26T08:21:26+08:00">2019-11-26</time>
            </span>
          

          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">1.4k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">1 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: s = “anagram”, t = “nagaram”</p>
<p>输出: true<br>示例 2:</p>
<p>输入: s = “rat”, t = “car”</p>
<p>输出: false</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>用HashMap来做最简单就是先把第一个字符串所有字符都存起来，遍历第二个字符串挨个剔除有的字符。</p>
<p>还有一个利用equals特性，先把所有字符排序，排序好后直接用String的equals方法判定。</p>
<h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] chars1 = t.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(aChar))&#123;</span><br><span class="line">                map.replace(aChar,map.get(aChar) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(aChar,<span class="number">1</span>);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars1) &#123;</span><br><span class="line">            <span class="comment">//字符出现一次直接删除</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c) &amp;&amp; map.get(c) == <span class="number">1</span>)&#123;</span><br><span class="line">                map.remove(c);</span><br><span class="line">            <span class="comment">//出现两次取value-1</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">                map.replace(c,map.get(c) - <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram_1</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] chars1 = t.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        Arrays.sort(chars1);</span><br><span class="line">        <span class="comment">//这里把排序后的字符串用String的equals判断也可以</span></span><br><span class="line">        <span class="keyword">return</span> String.valueOf(chars).equals(String.valueOf(chars1));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/25/07-GC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="96gh'home">
      <meta itemprop="description" content="闲敲棋子落灯花">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/25/07-GC/" class="post-title-link" itemprop="url">07-GC</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-25 13:07:48" itemprop="dateCreated datePublished" datetime="2019-11-25T13:07:48+08:00">2019-11-25</time>
            </span>
          

          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">6.4k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">6 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JVM为我们管理垃圾对象实现自动回收，让我们不需要太关心内存释放问题，一定程度上减少了内存溢出的错误。这一切的背后是如何实现的呢？下面来看一下。</p>
<h2 id="垃圾标记算法"><a href="#垃圾标记算法" class="headerlink" title="垃圾标记算法"></a><font color="#8B475D">垃圾标记算法</font></h2><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="#引用计数法"></a>#<font color="#367bdd">引用计数法</font></h5><ul>
<li>主要思想：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加一；当引用失效时，计数器减一；任何时候计数器为0的对象是不可能再被使用的。</li>
<li>主要缺陷：无法解决对象间相互循环引用的问题。</li>
</ul>
<p>小栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Test objA = <span class="keyword">new</span> Test();<span class="comment">//count = 1</span></span><br><span class="line">        Test objB = <span class="keyword">new</span> Test();<span class="comment">//count = 1</span></span><br><span class="line"></span><br><span class="line">        objA.instance = objB; <span class="comment">//count = 2</span></span><br><span class="line">        objB.instance = objA; <span class="comment">//count = 2</span></span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>; <span class="comment">//count = 1</span></span><br><span class="line">        objB = <span class="keyword">null</span>; <span class="comment">//count = 1</span></span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testGC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 6770K-&gt;744K(38400K)] 6770K-&gt;752K(125952K), 0.0020546 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 744K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;626K(87552K)] 752K-&gt;626K(125952K), [Metaspace: 3212K-&gt;3212K(1056768K)], 0.0058036 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 38400K, used 333K [0x00000000d5f00000, 0x00000000d8980000, 0x0000000100000000)</span><br><span class="line">  eden space 33280K, 1% used [0x00000000d5f00000,0x00000000d5f534a8,0x00000000d7f80000)</span><br><span class="line">  from space 5120K, 0% used [0x00000000d7f80000,0x00000000d7f80000,0x00000000d8480000)</span><br><span class="line">  to   space 5120K, 0% used [0x00000000d8480000,0x00000000d8480000,0x00000000d8980000)</span><br><span class="line"> ParOldGen       total 87552K, used 626K [0x0000000081c00000, 0x0000000087180000, 0x00000000d5f00000)</span><br><span class="line">  object space 87552K, 0% used [0x0000000081c00000,0x0000000081c9cb18,0x0000000087180000)</span><br><span class="line"> Metaspace       used 3219K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>结果中从6770K-&gt;744K(38400K)，从原来的6M变成700多k，表名对象已经被回收，从而说明JVM没有使用引用计数算法。Java中使用了可达性分析算法来来判定对象是否存活。</p>
<h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="#可达性分析算法"></a>#<font color="#367bdd">可达性分析算法</font></h5><p>这个算法的基本思路就是通过一系列的称谓<code>GC Roots</code>的对象作为起始点，从这些节点开始向下搜索，搜索所有走过的路径为引用链，当一个对象到<code>GC Roots</code>没有任何引用链时，则证明此对象时不可用的，下面看一下例子：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/JVM/jvm8-1.png" alt="image"></p>
<p>上面的这张图，对象object5、object6、object7虽然互相关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象.</p>
<p>关键在于<code>GCRoots</code>。</p>
<p>Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI(即一般说的<code>Native</code>方法)引用的对象</li>
<li>活跃线程引用的对象</li>
</ul>
<p>总结就是一切JVM中栈和方法区和当前执行线程引用到的对象都可以作为根。</p>
<h2 id="Java中的引用类型"><a href="#Java中的引用类型" class="headerlink" title="Java中的引用类型"></a><font color="#8B475D">Java中的引用类型</font></h2><p>将引用分为强引用，软引用，弱引用，虚引用，这四种引用的强度一次逐渐减弱。</p>
<ul>
<li>强引用就是指在程序代码之中普遍存在的，类似 Object obj = new Object() 这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。</li>
<li>软引用是用来描述一些还有用但并非需要的对象，对于软引用关联着的对象，在系统将要发生内存异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存异常</li>
<li>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存释放足够，都会回收掉只被弱引用关联的对象</li>
<li>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，对一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>
<h2 id="两次标记"><a href="#两次标记" class="headerlink" title="两次标记"></a><font color="#8B475D">两次标记</font></h2><p>《深入理解java虚拟机》原文：</p>
<blockquote>
<p><font color="#333">在java根搜索算法中判断对象的可达性，对于不可达的对象，也并不一定是必须清理。这个时候有一个缓刑期，真正的判断一个对象死亡，至少要经过俩次标记过程：<br><br>如果对象在进行根搜索后发现没有与<code>GC roots</code>相关联的引用链，那他将会第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法，当对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，虚拟机将这俩种情况都视为“没有必要执行”。  <br> <br><br>即当一个对象重写了<code>finalize()</code>方法的时候，这个对象被判定为有必要执行<code>finalize()</code>方法，那么这个对象被放置在<code>F-Queue</code>队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的<code>Finalizer</code>线程去执行。这里所谓的执行是指虚拟机会出发这个方法，但不承诺会等待它运行结束。这样做的原因：如果一个对象在<code>finalize()</code>方法中执行缓慢，或者发生了死循环（极端的情况下），将可能会导致<code>F-Queue</code>队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。<code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会，稍后GC将对<code>F-Queue</code>中的对象进行第二次小规模的标记，如果对象要在<code>finalize()</code>中成功拯救自己—-只要重新与引用链上的任何建立关联即可，那么在第二次标记时它将会被移出“即将回收”的集合；如果对象这时候没有逃脱，就会被回收。 <br><br></font></p>
</blockquote>
<h5 id="finalize的工作原理"><a href="#finalize的工作原理" class="headerlink" title="#finalize的工作原理"></a>#<font color="#367bdd">finalize的工作原理</font></h5><p>一旦垃圾收集器准备好释放对象占用的存储空间，它首先调用<code>finalize()</code>，而且只有在下一次垃圾收集过程中，才会真正回收对象的内存.所以如果使用<code>finalize()</code>，就可以在垃圾收集期间进行一些重要的清除或清扫工作.</p>
<h5 id="finalize-在什么时候被调用"><a href="#finalize-在什么时候被调用" class="headerlink" title="#finalize()在什么时候被调用?"></a>#<font color="#367bdd">finalize()在什么时候被调用?</font></h5><ul>
<li>所有对象被<code>Garbage Collection</code>时自动调用,比如运行<code>System.gc()</code>的时候.</li>
<li>程序退出时为每个对象调用一次<code>finalize</code>方法。</li>
<li>显式的调用<code>finalize</code>方法</li>
</ul>
<p>这个方法的用途就是：在该对象被回收之前，该对象的<code>finalize()</code>方法会被调用。这里的回收之前指的就是被标记之后，问题就出在这里，有没有一种情况就是原本一个对象开始不再上一章所讲的“关系网”（引用链）中，但是当开发者重写了<code>finalize()</code>后，并且将该对象重新加入到了“关系网”中，也就是说该对象对我们还有用，不应该被回收，但是已经被标记啦，怎么办呢？</p>
<p>针对这个问题，虚拟机的做法是进行两次标记，即第一次标记不在“关系网”中的对象，并且要判断该对象有没有实现finalize()方法了，如果没有实现就直接判断该对象可回收。如果实现了就会先放在一个队列中，并由虚拟机建立的一个低优先级的线程去执行它。</p>
<p>随后就会进行第二次的小规模标记，如果对象还没有逃脱，在这次被标记的对象就会真正的被回收了。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a><font color="#8B475D">垃圾收集算法</font></h2><h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="#标记-清除算法"></a>#<font color="#367bdd">标记-清除算法</font></h5><p>最基础的收集算法是“标记-清除”（<code>Mark-Sweep</code>）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经基本介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。<strong>它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</strong></p>
<p>标记-清除算法的执行过程如图：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/JVM/jvm8-2.jpg" alt="image"></p>
<h5 id="复制算法"><a href="#复制算法" class="headerlink" title="#复制算法"></a>#<font color="#367bdd">复制算法</font></h5><p>为了解决效率问题，一种称为“复制”（<code>Copying</code>）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<strong>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。</strong></p>
<p>复制算法的执行过程如图：</p>
<p><img src="http://blog-picture-g.test.upcdn.net/JVM/jvm8-3.jpg" alt="image"></p>
<h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="#标记-整理算法"></a>#<font color="#367bdd">标记-整理算法</font></h5><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，<strong>就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</strong></p>
<p>根据老年代的特点，有人提出了另外一种“标记-整理”（<code>Mark-Compact</code>）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如图:</p>
<p><img src="http://blog-picture-g.test.upcdn.net/JVM/jvm8-4.jpg" alt="image"></p>
<h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="#分代收集算法"></a>#<font color="#367bdd">分代收集算法</font></h5><p>当前商业虚拟机的垃圾收集都采用“分代收集”（<code>Generational Collection</code>）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。<strong>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收.</strong></p>
<p><img src="http://blog-picture-g.test.upcdn.net/JVM/jvm8-5.jpg" alt="image"></p>
<h2 id="新生代和老年代"><a href="#新生代和老年代" class="headerlink" title="新生代和老年代"></a><font color="#8B475D">新生代和老年代</font></h2><h5 id="新生代"><a href="#新生代" class="headerlink" title="#新生代"></a>#<font color="#367bdd">新生代</font></h5><p>新生代分为三个区域，一个<code>Eden</code>区和两个<code>Survivor</code>区，它们之间的比例为（<code>8：1：1</code>），这个比例也是可以修改的。通常情况下，对象主要分配在新生代的<code>Eden</code>区上，少数情况下也可能会直接分配在老年代中。</p>
<p>Java虚拟机每次使用新生代中的<code>Eden</code>和其中一块<code>Survivor（From）</code>，在经过一次<code>MinorGC</code>后，将<code>Eden</code>和<code>Survivor</code>中还存活的对象一次性地复制到另一块<code>Survivor</code>空间上（这里使用的复制算法进行GC），最后清理掉<code>Eden</code>和刚才用过的<code>Survivor（From）</code>空间。将此时在<code>Survivor</code>空间存活下来的对象的年龄设置为1，以后这些对象每在<code>Survivor</code>区熬过一次GC，它们的年龄就加1，当对象年龄达到某个年龄（默认值为15）时，就会把它们移到老年代中。</p>
<p>总结：</p>
<ul>
<li><code>Minor GC</code>是发生在新生代中的垃圾收集，采用的复制算法；</li>
<li>新生代中每次使用的空间不超过90%，主要用来存放新生的对象；</li>
<li><code>Minor GC</code>每次收集后<code>Eden</code>区和一块<code>Survivor</code>区都被清空；</li>
</ul>
<h5 id="老年代"><a href="#老年代" class="headerlink" title="#老年代"></a>#<font color="#367bdd">老年代</font></h5><p>老年代里面存放都是生命周期长的对象，对于一些较大的对象（即需要分配一块较大的连续内存空间），是直接存入老年代的，还有很多从新生代的<code>Survivor</code>区域中熬过来的对象。</p>
<p>老年代中使用的是<code>Full GC</code>，<code>Full GC</code>所采用的是标记-清除或者标记-整理算法。老年代中的<code>Full GC</code>不像<code>Minor GC</code>操作那么频繁，并且进行一次<code>Full GC</code>所需要的时间要比<code>Minor GC</code>的时间长。</p>
<h5 id="触发Full-GC的条件"><a href="#触发Full-GC的条件" class="headerlink" title="#触发Full GC的条件"></a>#<font color="#367bdd">触发Full GC的条件</font></h5><ul>
<li>老年代空间不足</li>
<li><code>JDK8</code>以前的永久代空间不足，现在永久代已经被元数据区代替</li>
<li><code>CMS GC</code>时出现<code>promotion failed</code>，<code>concurrent mode failure</code>(下面文章讲到CMS垃圾收集器的时候会说明)</li>
<li><code>minor GC</code>晋升到老年代的平均大小大于老年代的剩余空间</li>
<li>调用<code>System.gc()</code>提醒JVM回收一下，只是提醒,虚拟机不会立即执行。</li>
</ul>
<h5 id="对象如何晋升到老年代"><a href="#对象如何晋升到老年代" class="headerlink" title="#对象如何晋升到老年代"></a>#<font color="#367bdd">对象如何晋升到老年代</font></h5><p>一般有如下情况会晋升：</p>
<ul>
<li>经历一定<code>minor</code>次数依然存活的对象</li>
<li><code>survivor</code>区中存放不下的对象</li>
<li>新生成的大对象</li>
</ul>
<h5 id="常用的调优参数"><a href="#常用的调优参数" class="headerlink" title="#常用的调优参数"></a>#<font color="#367bdd">常用的调优参数</font></h5><ul>
<li><code>-XX:SurvivorRatio:</code> <code>Enden</code>和<code>Survivor</code>的比值，默认8：1</li>
<li><code>-XX:NewRatio</code>:老年代和年轻代内存大小的比例。</li>
<li><code>-XX:MaxTenuringThreshold</code>:对象从年轻代晋升到老年代经过GC次数的最大阈值。</li>
</ul>
<h2 id="内存申请过程"><a href="#内存申请过程" class="headerlink" title="内存申请过程"></a><font color="#8B475D">内存申请过程</font></h2><p>A. JVM会试图为相关Java对象在<code>Eden</code>中初始化一块内存区域</p>
<p>B. 当<code>Eden</code>空间足够时，内存申请结束。否则到下一步</p>
<p>C. <code>JVM</code>试图释放在<code>Eden</code>中所有不活跃的对象（<code>Minor GC</code>）, 释放后若<code>Eden</code>空间仍然不足以放入新对象，则试图将部分<code>Eden</code>中活跃对象放入<code>Survivor</code>区</p>
<p>D. 当<code>Survivor</code>区空间不够时或者某些对象熬的时间比较长，则<code>Survivor</code>区这些对象会被移到<code>Old</code>区</p>
<p>E. 当<code>Old</code>区空间不够时，JVM会在<code>Old</code>区进行完全的垃圾收集（<code>Full GC</code>）</p>
<p>F. 完全垃圾收集后，若<code>Survivor</code>及<code>Old</code>区仍然无法存放从<code>Eden</code>复制过来的部分对象，导致JVM无法在<code>Eden</code>区为新对象创建内存区域，则出现<code>out of memory</code>错误.</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/25/08-垃圾收集器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="96gh'home">
      <meta itemprop="description" content="闲敲棋子落灯花">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/25/08-垃圾收集器/" class="post-title-link" itemprop="url">08-垃圾收集器</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-25 13:07:48" itemprop="dateCreated datePublished" datetime="2019-11-25T13:07:48+08:00">2019-11-25</time>
            </span>
          

          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">3.5k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">3 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果说收集算法是内存回收的方法，那么本文主要介绍七种比较经典的垃圾收集器。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a><font color="#8B475D">垃圾收集器</font></h2><p><img src="http://blog-picture-g.test.upcdn.net/JVM/jvm9-1.jpg" alt="image"></p>
<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a><font color="#8B475D">Serial 收集器</font></h2><p><img src="http://blog-picture-g.test.upcdn.net/JVM/jvm9-2.jpg" alt="image"></p>
<p><code>Serial</code> 翻译为串行,垃圾收集和用户程序不能同时执行，这意味着在执行垃圾收集的时候需要停顿用户程序。除了 CMS 和 G1 之外，其它收集器都是以串行的方式执行。CMS 和 G1 可以使得垃圾收集和用户程序同时执行，被称为并发执行。</p>
<p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p>
<p>它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p>
<p>它是 <code>Client</code>模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。<code>Serial</code> 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p>
<h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a><font color="#8B475D">ParNew 收集器</font></h2><p><img src="http://blog-picture-g.test.upcdn.net/JVM/jvm9-3.jpg" alt="image"></p>
<p>它是 Serial 收集器的多线程版本。</p>
<p>是 <code>Server</code>模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了<code>Serial</code> 收集器，只有它能与 <code>CMS</code> 收集器配合工作。</p>
<h2 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a><font color="#8B475D">Parallel Scavenge 收集器</font></h2><p>与 <code>ParNew</code>一样是并行的多线程收集器。</p>
<p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p>提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 <code>-XX:MaxGCPauseMillis</code> 参数以及直接设置吞吐量大小的 <code>-XX:GCTimeRatio</code> 参数（值为大于 0 且小于 100 的整数）。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
<p>还提供了一个参数 <code>-XX:+UseAdaptiveSizePolicy</code>，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（<code>-Xmn</code>）、<code>Eden</code> 和 <code>Survivor</code> 区的比例（<code>-XX:SurvivorRatio</code>）、晋升老年代对象年龄（<code>-XX:PretenureSizeThreshold</code>）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（<code>GC Ergonomics</code>）。</p>
<h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a><font color="#8B475D">Serial Old 收集器</font></h2><p><img src="http://blog-picture-g.test.upcdn.net/JVM/jvm9-4.jpg" alt="image"></p>
<p>是 <code>Serial</code> 收集器的老年代版本，也是给 <code>Client</code> 模式下的虚拟机使用。如果用在<code>Server</code> 模式下，它有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本（<code>Parallel Old</code> 诞生以前）中与 <code>Parallel Scavenge</code> 收集器搭配使用。</li>
<li>作为 <code>CMS</code> 收集器的后备预案，在并发收集发生 <code>Concurrent Mode Failure</code> 时使用。</li>
</ul>
<h2 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><font color="#8B475D">Parallel Old 收集器</font></h2><p><img src="http://blog-picture-g.test.upcdn.net/JVM/jvm9-5.jpg" alt="image"></p>
<p>是 <code>Parallel Scavenge</code>收集器的老年代版本。</p>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 <code>Parallel Scavenge</code> 加<code>Parallel Old</code> 收集器。</p>
<h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title=" CMS 收集器"></a><font color="#8B475D"> CMS 收集器</font></h2><p><img src="http://blog-picture-g.test.upcdn.net/JVM/jvm9-6.jpg" alt="image"></p>
<p><code>CMS</code>（<code>Concurrent Mark Sweep</code>），<code>Mark Sweep</code> 指的是标记 - 清除算法。</p>
<p>特点：并发收集、低停顿。并发指的是用户线程和 GC 线程同时运行。</p>
<p>分为以下四个流程：</p>
<ul>
<li>初始标记：仅仅只是标记一下<code>GC Roots</code> 能直接关联到的对象，速度很快，需要停顿。</li>
<li>并发标记：进行<code>GC Roots Tracing</code> 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li>并发清除：不需要停顿。</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p>具有以下缺点：</p>
<ul>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 <code>CPU</code> 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 <code>Concurrent Mode Failure</code>。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着<code>CMS</code> 收集不能像其它收集器那样等待老年代快满的时候再回收。可以使用 <code>-XX:CMSInitiatingOccupancyFraction</code> 来改变触发 <code>CMS</code> 收集器工作的内存占用百分，如果这个值设置的太大，导致预留的内存不够存放浮动垃圾，就会出现 <code>Concurrent Mode Failure</code>，这时虚拟机将临时启用 <code>Serial Old</code> 来替代 <code>CMS</code>。</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 <code>Full GC</code>。</li>
</ul>
<h2 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a><font color="#8B475D">G1 收集器</font></h2><p><code>G1（Garbage-First）</code>，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。<code>HotSpot</code> 开发团队赋予它的使命是未来可以替换掉 <code>CMS</code> 收集器。</p>
<p>Java 堆被分为新生代、老年代和永久代，其它收集器进行收集的范围都是整个新生代或者老生代，而 G1 可以直接对新生代和永久代一起回收。</p>
<p><img src="http://blog-picture-g.test.upcdn.net/JVM/jvm9-7.png" alt="image"></p>
<p>G1 把新生代和老年代划分成多个大小相等的独立区域（<code>Region</code>），新生代和永久代不再物理隔离。</p>
<p><img src="http://blog-picture-g.test.upcdn.net/JVM/jvm9-8.png" alt="image"></p>
<p>通过引入 <code>Region</code> 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 <code>Region</code> 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 <code>Region</code>。</p>
<p>每个 <code>Region</code> 都有一个 <code>Remembered Set</code>，用来记录该 <code>Region</code> 对象的引用对象所在的 <code>Region</code>。通过使用 <code>Remembered Set</code>，在做可达性分析的时候就可以避免全堆扫描。</p>
<p><img src="http://blog-picture-g.test.upcdn.net/JVM/jvm9-9.jpg" alt="image"></p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 <code>Remembered Set Logs</code> 里面，最终标记阶段需要把 <code>Remembered Set Logs</code> 的数据合并到 <code>Remembered Set</code> 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个 <code>Region</code> 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 <code>Region</code>，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p>具备如下特点：</p>
<ul>
<li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 <code>Region</code> 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<h2 id="收集器比较"><a href="#收集器比较" class="headerlink" title="收集器比较"></a><font color="#8B475D">收集器比较</font></h2><p>收集器 | 串行/并行/并发 | 新生代/老年代    | 收集算法 | 目标<br>—|— | — | — | — | —<br>Serial | 串行 | 新生代 | 复制 |     响应速度优先<br>Serial Old     | 串行 | 老年代 | 标记-整理 | 响应速度优先<br>ParNew |     串行 + 并行 |    新生代 | 复制算法 | 吞吐量优先<br>Parallel Scavenge | 串行 + 并行 | 新生代 |     复制算法 | 吞吐量优先<br>Parallel Old |     串行 + 并行 | 老年代 | 标记-整理 | 响应速度优先<br>CMS | 并行 + 并发 |    老年代 | 标记-清除 | 响应速度优先<br>G1 | 并行 + 并发 |    新生代 + 老年代 | 标记-整理 + 复制算法 | 响应速度优先</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/25/06-线程共享内存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="96gh'home">
      <meta itemprop="description" content="闲敲棋子落灯花">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/25/06-线程共享内存/" class="post-title-link" itemprop="url">06-线程共享内存</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-25 11:07:48" itemprop="dateCreated datePublished" datetime="2019-11-25T11:07:48+08:00">2019-11-25</time>
            </span>
          

          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">2.2k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">2 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上节我们介绍了线程私有的内存区域，这节我们看下内存共享的区域。</p>
<h2 id="内存模型–JAVA堆"><a href="#内存模型–JAVA堆" class="headerlink" title="内存模型–JAVA堆"></a><font color="#8B475D">内存模型–JAVA堆</font></h2><ul>
<li><p>java堆一般是java虚拟机所管理的内存中最大的一块。</p>
</li>
<li><p>java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p>
</li>
<li><p>堆上存放对象实例和数组。</p>
</li>
<li><p>java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</p>
</li>
<li><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常。</p>
</li>
</ul>
<h2 id="内存模型–方法区"><a href="#内存模型–方法区" class="headerlink" title="内存模型–方法区"></a><font color="#8B475D">内存模型–方法区</font></h2><p><img src="http://blog-picture-g.test.upcdn.net/JVM/jvm6-1.png" alt="image"></p>
<ul>
<li><p>方法区和堆一样，是各个线程共享的内存区域。</p>
</li>
<li><p>它用于存储已被虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码等数据。</p>
</li>
<li><p>其中，类信息包含类的版本、字段、接口、方法</p>
</li>
</ul>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><font color="#8B475D">运行时常量池</font></h2><ul>
<li>方法区的一部分。</li>
<li>类文件中除了类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法的运行时常量池中存放。</li>
<li>这里尤其值得注意的是字符串的创建，会被扔到字符串常量池中。如果是new，那么还是在堆重创建的。当然，运行时也可以产生新的常量放入池中，比如讲new出来的字符串用<code>intern()</code>方法便可以在运行时将其放到常量池中。</li>
</ul>
<h5 id="小栗子"><a href="#小栗子" class="headerlink" title="#小栗子"></a>#<font color="#367bdd">小栗子</font></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  String str1 = <span class="string">"hello"</span>;</span><br><span class="line">  String str2 = <span class="string">"hello"</span>;</span><br><span class="line">  </span><br><span class="line">  System.out.println(str1 == str2); <span class="comment">//true</span></span><br><span class="line">  </span><br><span class="line">  String str3 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">  </span><br><span class="line">  System.out.println(str1 == str3); <span class="comment">//false</span></span><br><span class="line">  </span><br><span class="line">  System.out.println(str1 == str3.intern()); <span class="comment">//true </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于直接声明的内容相同的字符串，对于<code>str2</code>来说是不需要重新分配地址的，因为<code>str1</code>的<code>hello</code>这个常量已经存在于常量池中了。所以他们两个其实是一个东西。</p>
<p>对于<code>new</code>出来的<code>str3</code>，是不会直接扔到常量池中的，他是在堆中分配，地址不一样，所以显然是<code>false</code>。</p>
<p><code>String</code>类的<code>intern()</code>方法，使得运行时将堆中产生的对象放入常量池中，所以是<code>true</code>。</p>
<p>这个可以参考我的字符串的不可变性，那篇分析字符串比较详细。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a><font color="#8B475D">对象</font></h2><h5 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="#对象的创建过程"></a>#<font color="#367bdd">对象的创建过程</font></h5><ul>
<li>类加载检查：检查该对象的类是否已经被加载、解析、初始化过，如果没有则先进行类加载操作。</li>
<li>分配内存：如果内存规整使用“指针碰撞”分配，否则一般使用“空闲列表”分配，具体看垃圾回收器是否带有整理（<code>Compact</code>）空闲内存功能。</li>
<li>初始化：将内存区初始化置零，不包含对象头，这一步保证了对象的实例字段在java代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li>对象头设置：这个对象是哪个类的实例、如何找到类的元数据信息、哈希码、GC分代年龄信息等即为对象头</li>
<li>对象的方法：即按照程序员的意愿进行初始化</li>
</ul>
<h5 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="#对象的内存布局"></a>#<font color="#367bdd">对象的内存布局</font></h5><ul>
<li>对象头</li>
</ul>
<p><strong>一部分称为<code>Mark Word</code>，存储对象自身运行时的数据</strong>，包含哈希码、GC分代年龄、锁状态标志等等。</p>
<p>采用压缩存储，压缩到虚拟机位数（32位/64位）。由于对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，<code>Mark Word</code>被设计为一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p>
<p><strong>另一部分为类型指针，指向它的类元数据，虚拟机通过这个指针来确定这个对象是哪个类的实例。</strong> 并不是所有虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息不一定要经过对象本身。</p>
<p>如果对象是一个java数组，那么在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通java对象的元数据信息确定java对象的大小，但是从数组的元数据中却无法确定数组的大小。</p>
<ul>
<li>实例数据<ul>
<li>实例数据部分是对象真正存储的有效信息，也是在程序中定义的各种类型的字段内容。</li>
<li>无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</li>
<li>从分配策略中可以看出，相同宽度的字段总是分配在一起，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。</li>
</ul>
</li>
<li>对齐填充<ul>
<li>非必需，只有前两者加起来非8的倍数时才会有。</li>
<li>因为<code>HotSpot VM</code> 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说，对象的大小必须是8字节的整数倍。不对齐的时候，需要通过它来填充对齐。</li>
</ul>
</li>
</ul>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a><font color="#8B475D">对象的访问定位</font></h2><h5 id="通过句柄访问"><a href="#通过句柄访问" class="headerlink" title="#通过句柄访问"></a>#<font color="#367bdd">通过句柄访问</font></h5><p><img src="http://blog-picture-g.test.upcdn.net/JVM/jvm6-2.png" alt="image"></p>
<p>通过句柄访问对象：当java虚拟机GC移动堆对象时，并不需要修改<code>reference</code>，只需修改句柄对象的实例数据指针。</p>
<h5 id="通过直接指针访问"><a href="#通过直接指针访问" class="headerlink" title="#通过直接指针访问"></a>#<font color="#367bdd">通过直接指针访问</font></h5><p><img src="http://blog-picture-g.test.upcdn.net/JVM/jvm6-3.png" alt="image"></p>
<p>通过直接指针访问对象：加快了对象访问速度，比间接访问少一次对象实例数据的访问，<code>HotSpot</code>则采用的这种访问方式。</p>
<p>整理自：</p>
<ul>
<li><a href="https://blog.csdn.net/u010349169/article/details/50412126" target="_blank" rel="noopener">https://blog.csdn.net/u010349169/article/details/50412126</a></li>
<li><a href="https://blog.csdn.net/daxiong_t/article/details/105877979" target="_blank" rel="noopener">https://blog.csdn.net/daxiong_t/article/details/105877979</a></li>
</ul>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/25/leetCode-239-滑动窗口最大值/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="96gh'home">
      <meta itemprop="description" content="闲敲棋子落灯花">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/25/leetCode-239-滑动窗口最大值/" class="post-title-link" itemprop="url">leetCode-239-滑动窗口最大值</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-25 08:21:26" itemprop="dateCreated datePublished" datetime="2019-11-25T08:21:26+08:00">2019-11-25</time>
            </span>
          

          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">2.7k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">2 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</p>
<p>输出: [3,3,5,5,6,7] </p>
<p>解释:（下面[]为每次移动的窗口）   </p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3</p>
<p>1 [3  -1  -3] 5  3  6  7       3</p>
<p>1  3 [-1  -3  5] 3  6  7       5</p>
<p>1  3  -1 [-3  5  3] 6  7       5</p>
<p>1  3  -1  -3 [5  3  6] 7       6</p>
<p>1  3  -1  -3  5 [3  6  7]      7</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>既然这个题目是老师从优先队列提到的，先看下优先队列实现，大概就是把每k个元素添加到大顶堆里，然后每过一个窗口都删除前一个元素添加一个后面的元素，保持堆的大小为K。但是这样做的话，每次大顶堆都需要删除前一个元素添加后面一个元素，堆要进行维护复杂度是<code>(logk)</code>，所以总的复杂度是<code>N(logk)</code></p>
<p>比较好的一个方法是用双端队列，整体思路是这样的，每次进入一个元素都保持队首的元素是最大的（如果新进来的元素大于当前队首元素，删除所有队列前面元素），因为双端队列基于链表实现，删除和增加都是<code>O(1)</code>所以总的时间复杂度是<code>o(N)</code>。</p>
<h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><p>优先队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//如果k的值大于数组的长度，直接返回数组最大元素就可以了</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt;= nums.length)&#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="keyword">return</span> nums.length == <span class="number">0</span> ? <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125; : <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;nums[nums.length - <span class="number">1</span>]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先把前K个元素添加到大顶堆中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            priorityQueue.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arr= <span class="keyword">new</span> <span class="keyword">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//循环从堆中返回元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k, j= <span class="number">0</span>; i &lt; nums.length; i++,j++)&#123;</span><br><span class="line">            arr[j] = priorityQueue.peek();</span><br><span class="line">            priorityQueue.remove(nums[j]);</span><br><span class="line">            priorityQueue.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[nums.length-k] = priorityQueue.peek();</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双端队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k &gt;= nums.length)&#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="keyword">return</span> nums.length == <span class="number">0</span> ? <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125; : <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;nums[nums.length - <span class="number">1</span>]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result= <span class="keyword">new</span> <span class="keyword">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//双端队列，来记录窗口值</span></span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//前面比k小的，直接移出队列（因为不再可能成为后面滑动窗口的最大值）</span></span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt; nums[i])&#123;</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.addLast(i);</span><br><span class="line">            <span class="comment">//前面比k大的X，比较两者下标，判断X是否已不在窗口之内，不在了，直接移出队列外</span></span><br><span class="line">            <span class="keyword">if</span> (queue.peekFirst() == i - k) &#123;</span><br><span class="line">                queue.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向result列表中加入元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                result[i - k + <span class="number">1</span>] = nums[queue.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/24/leetCode-15-三数之和/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="96gh'home">
      <meta itemprop="description" content="闲敲棋子落灯花">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="To be or not to be?">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/24/leetCode-15-三数之和/" class="post-title-link" itemprop="url">leetCode-15-三数之和</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-24 10:25:10" itemprop="dateCreated datePublished" datetime="2019-11-24T10:25:10+08:00">2019-11-24</time>
            </span>
          

          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">3.4k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">3 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><font color="#8B475D">题目描述</font></h2><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<blockquote>
<p>示例 ：</p>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：</p>
<p>[</p>
<p> [-1, 0, 1],</p>
<p>  [-1, -1, 2]</p>
<p>]</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><font color="#8B475D">解题思路</font></h2><p>第一种解法是暴力求解，三层循环枚举所有可能(需要注意的是会有大量重复结果)，复杂度是<code>O(n^3)</code></p>
<p>第二种解法是用hashmap，就是把第三层循环改为从map中去查找(map查找时间复杂度是<code>O(1)</code>的)，但是需要额外的开辟一个map空间，时间复杂度是<code>O(n^2)</code>的。</p>
<p>第三种解法是双指针做法，整体思路是这样的，先把数组先排序，先遍历第一个数字，使用两个指针分别指向被遍历数字后面的第一个元素和最后一个元素，如果两个指针指向的两个元素和小于给定值，则前指针后移，增大两元素和；相反的，如果大于给定值则后指针前移，减小两元素和。而如果等于的话，解就找到了，如果直至两指针相遇还没找到，则无解。这个算法时间最坏复杂度是<code>O(n^2)</code>，但是不需要开辟额外的空间，算是目前最优解法了。</p>
<h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a><font color="#8B475D">代码提交</font></h2><p>hashmap：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">                map.put(nums[i], map.get(nums[i]) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//考虑3个0的情况</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(<span class="number">0</span>) &amp;&amp; map.get(<span class="number">0</span>) &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            lists.add(Arrays.asList(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存进list集合方便下面操作</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(map.keySet());</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; list.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list.get(i) * <span class="number">2</span> + list.get(j) == <span class="number">0</span> &amp;&amp; map.get(list.get(i)) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    lists.add(Arrays.asList(list.get(i), list.get(i), list.get(j)));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (list.get(i) + list.get(j) * <span class="number">2</span> == <span class="number">0</span> &amp;&amp; map.get(list.get(j)) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    lists.add(Arrays.asList(list.get(i), list.get(j), list.get(j)));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> num = -list.get(i) - list.get(j);</span><br><span class="line">                <span class="keyword">if</span> (num &gt; list.get(j) &amp;&amp; map.containsKey(num)) &#123;</span><br><span class="line">                    lists.add(Arrays.asList(list.get(i), list.get(j), num));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//去重，如果前一个元素和当前元素相同，会出现重复子集</span></span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左指针右指针</span></span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> k = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] + nums[k] + nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[j] + nums[k] + nums[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[j] + nums[k] + nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    lists.add(Arrays.asList(nums[i],nums[j],nums[k]));</span><br><span class="line">                    j++;</span><br><span class="line">                    k--;</span><br><span class="line">                    <span class="comment">//去重，当j++和k--两个元素都和刚进入的集合一样，同样会进入到集合</span></span><br><span class="line">                    <span class="keyword">while</span> (nums[j-<span class="number">1</span>] == nums[j] &amp;&amp; nums[k+<span class="number">1</span>] == nums[k] &amp;&amp; j &lt; k)&#123;</span><br><span class="line">                        j++;</span><br><span class="line">                        k--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="96gh'home">
            
              <p class="site-author-name" itemprop="name">96gh'home</p>
              <div class="site-description motion-element" itemprop="description">闲敲棋子落灯花</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">328</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com" title="GitHub &rarr; https://github.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/yourname" title="Weibo &rarr; https://weibo.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://stackoverflow.com/yourname" title="StackOverflow &rarr; https://stackoverflow.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/" title="blibili &rarr; "><i class="fa fa-fw fa-globe"></i>blibili</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://google.com/" title="https://google.com/" rel="noopener" target="_blank">谷歌</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://baidu.com/" title="http://baidu.com/" rel="noopener" target="_blank">百度</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://example.com/" title="http://example.com/" rel="noopener" target="_blank">友联1</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://example.com/" title="http://example.com/" rel="noopener" target="_blank">友联2</a>
                  </li>
                
              </ul>
            </div>
          

          
        </div>
      </div>

      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">96gh'home</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">859k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">13:01</span>
  
</div>








        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  





  
    
    
  
  <script color="0,0,0" opacity="0.5" zindex="-1" count="150" src="/lib/canvas-nest/canvas-nest.min.js"></script>









  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  


  
  
  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>
  

  

</body>
</html>
